<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Rust中的智能指针, 立身于大雪弥漫、浓雾障眼的山口，只能偶尔瞥见未必正确的路径，只需睁大双眼，昂起头颅，走好脚下的路，不管它通向何方。">
    <meta name="description" content="指针 （pointer）是一个包含内存地址的变量的通用概念。这个地址引用 “指向”（points at）一些其他数据。Rust 中最常见的指针是引用（reference）。引用以 &amp;amp; 符号为标志并借用了它们所指向的值。除了引用数据没">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="white"/>
    <title>Rust中的智能指针 | Sparks Fly</title>
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link rel="icon" type="image/x-icon, image/vnd.microsoft.icon" href="/favicon.ico">
    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <style type="text/css">
        
        code[class*="language-"], pre[class*="language-"] {
            white-space: pre !important;
        }

        
    </style>
    <script src="/libs/jquery/jquery.min.js"></script>
<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Sparks Fly" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>

<header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                        <img src="/apple-touch-icon.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Sparks Fly</span>
                </a>
            </div>
            


<!-- <a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul> -->

<!-- 支持二级菜单特性 -->
<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right nav-menu">
    
        <li class="hide-on-med-and-down nav-item">

            
                <a href="/" class="waves-effect waves-light">
                    
                        <i class="fa fa-home"></i>
                    
                    <span>首页</span>
                </a>

            
        </li>
    
        <li class="hide-on-med-and-down nav-item">

            
                <a href="/categories" class="waves-effect waves-light">
                    
                        <i class="fa fa-bookmark"></i>
                    
                    <span>分类</span>
                </a>

            
        </li>
    
        <li class="hide-on-med-and-down nav-item">

            
                <a href="/archives" class="waves-effect waves-light">
                    
                        <i class="fa fa-archive"></i>
                    
                    <span>归档</span>
                </a>

            
        </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
            <img src="/medias/avatars/avatar.png"
                 class="logo-img circle responsive-img">
        
        <div class="logo-name">Sparks Fly</div>
        <div class="logo-desc">
            
                Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
            <li class="m-nav-item">
                
                    <a href="/" class="waves-effect waves-light">
                        
                            <i class="fa fa-fw fa-home"></i>
                        
                        首页
                    </a>
                
            </li>
        
            <li class="m-nav-item">
                
                    <a href="/categories" class="waves-effect waves-light">
                        
                            <i class="fa fa-fw fa-bookmark"></i>
                        
                        分类
                    </a>
                
            </li>
        
            <li class="m-nav-item">
                
                    <a href="/archives" class="waves-effect waves-light">
                        
                            <i class="fa fa-fw fa-archive"></i>
                        
                        归档
                    </a>
                
            </li>
        
        
    </ul>
</div>

        </div>

        
    </nav>

</header>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/1.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Rust中的智能指针</h1>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
        <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">Awsome</span>
                        </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                        <div class="post-cate">
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                                <a href="/categories/Rust/" class="post-category">
                                    Rust
                                </a>
                            
                        </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                    <div class="post-date info-break-policy">
                        <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                        2025-03-01
                    </div>
                

                
                    <div class="post-date info-break-policy">
                        <i class="fa fa-calendar-check-o fa-fw"></i>更新日期:&nbsp;&nbsp;
                        2025-03-01
                    </div>
                

                
                    <div class="info-break-policy">
                        <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                        9.9k
                    </div>
                

                
                    <div class="info-break-policy">
                        <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                        41 分
                    </div>
                

                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <p><strong>指针</strong> （<em>pointer</em>）是一个包含内存地址的变量的通用概念。这个地址引用 “指向”（points at）一些其他数据。Rust 中最常见的指针是<strong>引用（<em>reference</em>）</strong>。引用以 <code>&amp;</code> 符号为标志并借用了它们所指向的值。除了引用数据没有任何其他特殊功能，也没有额外开销。</p>
<p>另一方面，<strong>智能指针</strong>（<em>smart pointers</em>）是一类<strong>数据结构</strong>，它们的表现类似指针，但是也拥有额外的元数据和功能。智能指针的概念并不为 Rust 所独有；其起源于 C++ 并存在于其他语言中。Rust 标准库中定义了多种不同的智能指针，它们提供了多于引用的额外功能。为了探索其基本概念，我们来看看一些智能指针的例子，这包括 <strong>引用计数</strong> （<em>reference counting</em>）智能指针类型。</p>
<p>智能指针通常使用结构体实现。智能指针不同于结构体的地方在于其实现了 <code>Deref</code> 和 <code>Drop</code> trait。<code>Deref</code> trait 允许智能指针结构体实例表现的像引用一样，这样就可以编写既用于引用、又用于智能指针的代码。<code>Drop</code> trait 允许我们自定义当智能指针离开作用域时运行的代码。本章会讨论这些 trait 以及为什么对于智能指针来说它们很重要。</p>
<p>另外我们会涉及 <strong>内部可变性</strong>（<em>interior mutability</em>）模式，这是不可变类型暴露出改变其内部值的 API。我们也会讨论 <strong>引用循环</strong>（<em>reference cycles</em>）会如何泄漏内存，以及如何避免。</p>
<h2 id="1-使用Box指向堆上的数据"><a href="#1-使用Box指向堆上的数据" class="headerlink" title="1.使用Box指向堆上的数据"></a>1.使用<code>Box</code>指向堆上的数据</h2><p>使用<code>Box</code>指向堆上的数据，box 允许你将一个值放在堆上而不是栈上。留在栈上的则是指向堆数据的指针。</p>
<h3 id="Box-的特点"><a href="#Box-的特点" class="headerlink" title="Box 的特点"></a>Box<t> 的特点</t></h3><ul>
<li>在堆上分配值，而非栈上。</li>
<li>适用于确定大小的类型。</li>
<li>实现了 <code>Deref</code> 和 <code>Drop</code> 特性。</li>
</ul>
<p>除了数据被储存在堆上而不是栈上之外，box 没有性能损失。不过也没有很多额外的功能。它们多用于如下场景：</p>
<ul>
<li>当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候</li>
<li>当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候</li>
<li>当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是其具体类型的时候</li>
</ul>
<h3 id="1-Box-在堆上存储数据"><a href="#1-Box-在堆上存储数据" class="headerlink" title="1 .Box: 在堆上存储数据"></a>1 .Box<t>: 在堆上存储数据</t></h3><p>示例：创建 Box 指针 <code>src/main.rs</code></p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> a <span class="token operator">=</span> Box<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"a = {}"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里定义了变量 <code>b</code>，其值是一个指向被分配在堆上的值 <code>5</code> 的 <code>Box</code>。这个程序会打印出 <code>b = 5</code>；在这个例子中，我们可以像数据是储存在栈上的那样访问 box 中的数据。正如任何拥有数据所有权的值那样，当像 <code>b</code> 这样的 box 在 <code>main</code> 的末尾离开作用域时，它将被释放。这个释放过程作用于 box 本身（位于栈上）和它所指向的数据（位于堆上）。</p>
<p><code>let a = Box::new(5);</code> ：<code>5</code> 被 <strong>存储在堆（heap）上</strong>，而 <code>a</code> 本身是一个 <code>Box&lt;i32&gt;</code> 变量，它存储在栈上指向堆上的 <code>5</code>，有额外的指针开销。</p>
<p><code>let b = 5</code>; <code>5</code> 被 <strong>存储在栈（stack）上</strong>，<code>b</code> 直接存储 <code>i32</code> 值，访问速度更快，适用于简单标量值。</p>
<h3 id="2-Box允许创建递归类型"><a href="#2-Box允许创建递归类型" class="headerlink" title="2.Box允许创建递归类型"></a>2.Box允许创建递归类型</h3><p><strong>递归类型（<em>recursive type</em>）</strong>的值可以拥有另一个同类型的值作为其自身的一部分。但是这会产生一个问题，因为 Rust 需要在编译时知道类型占用多少空间。递归类型的值嵌套理论上可以无限地进行下去，所以 Rust 不知道递归类型需要多少空间。因为 box 有一个已知的大小，所以通过在循环类型定义中插入 box，就可以创建递归类型了。</p>
<p><code>src/lib.rs</code></p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">enum</span> List <span class="token punctuation">{</span>
    <span class="token function">Cons</span><span class="token punctuation">(</span>i32<span class="token punctuation">,</span> Box<span class="token operator">&lt;</span>List<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    Nil<span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">use</span> <span class="token keyword">crate</span><span class="token punctuation">:</span><span class="token punctuation">:</span>List<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">{</span>Cons<span class="token punctuation">,</span> Nil<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> list <span class="token operator">=</span> <span class="token function">Cons</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> Box<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token function">Cons</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> Box<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token function">Cons</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> Box<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>Nil<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>Cons</code> 成员将会需要一个 <code>i32</code> 的大小加上储存 box 指针数据的空间。<code>Nil</code> 成员不储存值，所以它比 <code>Cons</code> 成员需要更少的空间。现在我们知道了任何 <code>List</code> 值最多需要一个 <code>i32</code> 加上 box 指针数据的大小。通过使用 box，打破了这无限递归的连锁，这样编译器就能够计算出储存 <code>List</code> 值需要的大小了。</p>
<ul>
<li><code>Cons(i32, Box&lt;List&gt;)</code> 代表一个链表节点，包含一个 <code>i32</code> 值和一个指向 <strong>下一个节点的 <code>Box&lt;List&gt;</code></strong>。</li>
<li><code>Nil</code> 代表链表的结束。</li>
<li>通过 <code>Box&lt;T&gt;</code> 避免递归类型的无限大小问题，使 <code>List</code> 能够编译通过。</li>
<li>代码构造了一个 <code>1 -&gt; 2 -&gt; 3 -&gt; Nil</code> 的链表结构。</li>
</ul>
<h2 id="2-Deref-trait"><a href="#2-Deref-trait" class="headerlink" title="2 .Deref  trait"></a>2 .Deref  trait</h2><p>实现 <code>Deref</code> trait 允许我们重载 <strong>解引用运算符</strong>（<em>dereference operator</em>）<code>*</code>（不要与乘法运算符或通配符相混淆）。通过这种方式实现 <code>Deref</code> trait 的智能指针可以被当作常规引用来对待，可以编写操作引用的代码并用于智能指针。下面让我们来看看它具体有哪些作用：</p>
<h3 id="1-追踪指针的值"><a href="#1-追踪指针的值" class="headerlink" title="1.追踪指针的值"></a>1.追踪指针的值</h3><p><strong>常规引用是一个指针类型</strong>，一种理解指针的方式是将其看成指向储存在其他某处值的箭头。在下方的示例代码中，创建了一个 <code>i32</code> 值的引用，接着使用<code>解引用运算符(*)</code>来跟踪所引用的值：</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">de_refrence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//assert_eq!(y,5); //不允许比较数字的引用与数字，因为它们是不同的类型。必须使用解引用运算符追踪引用所指向的值。</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token operator">*</span>y<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>像引用一样使用 <code>Box</code></strong></p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">de_refrence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> y <span class="token operator">=</span> Box<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//智能指针</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token operator">*</span>y<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//使用解引用运算符来跟踪 i32 值的引用</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>两段代码主要不同的地方就是后者将 <code>y</code> 设置为一个指向 <code>x</code> 值拷贝的 <code>Box&lt;T&gt;</code> 实例，而不是指向 <code>x</code> 值的引用。在最后的断言中，可以使用解引用运算符以 <code>y</code> 为引用时相同的方式追踪 <code>Box&lt;T&gt;</code> 的指针。</p>
<h3 id="2-智能指针与引用的不同"><a href="#2-智能指针与引用的不同" class="headerlink" title="2.智能指针与引用的不同"></a>2.智能指针与引用的不同</h3><p>这里定义了一个结构体 <code>MyBox</code> 并声明了一个泛型参数 <code>T</code>，因为我们希望其可以存放任何类型的值。<code>MyBox</code> 是一个包含 <code>T</code> 类型元素的元组结构体。<code>MyBox::new</code> 函数获取一个 <code>T</code> 类型的参数并返回一个存放传入值的 <code>MyBox</code> 实例。</p>
<p>尝试和前面的<code>de_refrence()</code>一样使用 <code>MyBox&lt;T&gt;</code> 类型代替 <code>Box&lt;T&gt;</code>。</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">struct</span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">{</span>
    value<span class="token punctuation">:</span>T
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">new</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span>T<span class="token punctuation">)</span> <span class="token punctuation">-></span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">{</span>
        MyBox<span class="token punctuation">{</span>
            value<span class="token punctuation">:</span>x
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function">refrence_box_diff</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> y <span class="token operator">=</span> MyBox<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span><span class="token operator">*</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//type `MyBox&lt;{integer}>` cannot be dereferenced</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">refrence_box_diff</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>尝试编译得到的错误提示是<code>error[E0614]: type MyBox&lt;{integer}&gt; cannot be dereferenced:MyBox&lt;T&gt;</code> 类型不能解引用，因为我们尚未在该类型实现这个功能。为了启用 <code>*</code> 运算符的解引用功能，需要实现 <code>Deref</code> trait。</p>
<h3 id="3-通过实现-Deref-trait-将某类型像引用一样处理"><a href="#3-通过实现-Deref-trait-将某类型像引用一样处理" class="headerlink" title="3.通过实现 Deref trait 将某类型像引用一样处理"></a>3.通过实现 <code>Deref</code> trait 将某类型像引用一样处理</h3><pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>ops<span class="token punctuation">:</span><span class="token punctuation">:</span>Deref<span class="token punctuation">;</span>
<span class="token keyword">struct</span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">{</span>
    value<span class="token punctuation">:</span>T
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">new</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span>T<span class="token punctuation">)</span> <span class="token punctuation">-></span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">{</span>
        MyBox<span class="token punctuation">{</span>
            value<span class="token punctuation">:</span>x
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// Deref trait</span>
<span class="token keyword">impl</span><span class="token operator">&lt;</span>T<span class="token operator">></span> Deref <span class="token keyword">for</span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">type</span> Target <span class="token operator">=</span> T<span class="token punctuation">;</span>

    <span class="token keyword">fn</span> <span class="token function">deref</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span>Self<span class="token punctuation">:</span><span class="token punctuation">:</span>Target <span class="token punctuation">{</span>
        <span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">.</span>value
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function">refrence_box_deref</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> y <span class="token operator">=</span> MyBox<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span><span class="token operator">*</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">refrence_box_diff</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>type Target = T;</code> 语法定义了用于此 trait 的关联类型。</p>
<p><code>deref</code> 方法体中写入了 <code>&amp;self.value</code>，这样 <code>deref</code> 返回了我希望通过 <code>*</code> 运算符访问的值的引用</p>
<p>没有有 <code>Deref</code> trait 的话，编译器只会解引用 <code>&amp;</code> 引用类型。<code>deref</code> 方法向编译器提供了获取任何实现了 <code>Deref</code> trait 的类型的值，并且调用这个类型的 <code>deref</code> 方法来获取一个它知道如何解引用的 <code>&amp;</code> 引用的能力。</p>
<p>执行 <code>*y</code> 时，Rust 事实上在底层运行了如下代码： <code>*(y.deref())</code></p>
<p>Rust 将 <code>*</code> 运算符替换为先调用 <code>deref</code> 方法再进行普通解引用的操作，如此我们便不用担心是否还需手动调用 <code>deref</code> 方法了。Rust 的这个特性可以让我们写出行为一致的代码，无论是面对的是常规引用还是实现了 <code>Deref</code> 的类型。</p>
<p><code>deref</code> 方法返回值的引用，以及 <code>*(y.deref())</code> 括号外边的普通解引用仍为必须的原因在于所有权。如果 <code>deref</code> 方法直接返回值而不是值的引用，其值（的所有权）将被移出 <code>self</code>。在这里以及大部分使用解引用运算符的情况下我们并不希望获取 <code>MyBox&lt;T&gt;</code> 内部值的所有权。</p>
<h3 id="4-Deref-强制转换（deref-coercions）"><a href="#4-Deref-强制转换（deref-coercions）" class="headerlink" title="4.Deref 强制转换（deref coercions）"></a><strong>4.Deref 强制转换</strong>（<em>deref coercions</em>）</h3><p>将实现了 <code>Deref</code> trait 的类型的引用转换为另一种类型的引用。例如，可以将 <code>&amp;String</code> 转换为 <code>&amp;str</code>，因为 <code>String</code> 实现了 <code>Deref</code> trait 因此可以返回 <code>&amp;str</code>。</p>
<p>Deref 强制转换的加入使我们编写函数和方法调用时无需增加过多显式使用 <code>&amp;</code> 和 <code>*</code> 的引用和解引用。这个功能也使得我们可以编写更多同时作用于引用或智能指针的代码。下面是一个代码示例：</p>
<p><code>src/main.rs</code></p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>ops<span class="token punctuation">:</span><span class="token punctuation">:</span>Deref<span class="token punctuation">;</span>
<span class="token keyword">struct</span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">{</span>
    value<span class="token punctuation">:</span>T
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">new</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span>T<span class="token punctuation">)</span> <span class="token punctuation">-></span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">{</span>
        MyBox<span class="token punctuation">{</span>
            value<span class="token punctuation">:</span>x
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// Deref trait</span>
<span class="token keyword">impl</span><span class="token operator">&lt;</span>T<span class="token operator">></span> Deref <span class="token keyword">for</span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">type</span> Target <span class="token operator">=</span> T<span class="token punctuation">;</span>

    <span class="token keyword">fn</span> <span class="token function">deref</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span>Self<span class="token punctuation">:</span><span class="token punctuation">:</span>Target <span class="token punctuation">{</span>
        <span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">.</span>value
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">hello</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token operator">&amp;</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Hello, {name}!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">hello</span><span class="token punctuation">(</span><span class="token string">"bob"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//可以使用字符串 slice 作为参数调用 hello函数</span>

    <span class="token keyword">let</span> m <span class="token operator">=</span> MyBox<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>String<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"bob"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">hello</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//用 MyBox&lt;String> 类型值的引用调用 hello函数</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里使用 <code>&amp;m</code> 调用 <code>hello</code> 函数，其为 <code>MyBox&lt;String&gt;</code> 值的引用。因为在 <code>MyBox&lt;T&gt;</code> 上实现了 <code>Deref</code> trait，Rust 可以通过 <code>deref</code> 调用将 <code>&amp;MyBox&lt;String&gt;</code> 变为 <code>&amp;String</code>（标准库中提供了 <code>String</code> 上的 <code>Deref</code> 实现，其会返回字符串 slice，这可以在 <code>Deref</code> 的 API 文档中看到）。Rust 再次调用 <code>deref</code> 将 <code>&amp;String</code> 变为 <code>&amp;str</code>，这就符合 <code>hello</code> 函数的定义了。</p>
<p>如果 Rust 没有实现 Deref 强制转换，为了使用 <code>&amp;MyBox&lt;String&gt;</code> 类型的值调用 <code>hello</code>，则不得用下面的代码来实现了：</p>
<p><code>src/main.rs</code></p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>ops<span class="token punctuation">:</span><span class="token punctuation">:</span>Deref<span class="token punctuation">;</span>
<span class="token keyword">struct</span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">{</span>
    value<span class="token punctuation">:</span>T
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">new</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span>T<span class="token punctuation">)</span> <span class="token punctuation">-></span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">{</span>
        MyBox<span class="token punctuation">{</span>
            value<span class="token punctuation">:</span>x
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">hello</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token operator">&amp;</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Hello, {name}!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> m <span class="token operator">=</span> MyBox<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>String<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"Rust"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">hello</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">*</span>m<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>(*m)</code> 将 <code>MyBox&lt;String&gt;</code> 解引用为 <code>String</code>。接着 <code>&amp;</code> 和 <code>[..]</code> 获取了整个 <code>String</code> 的字符串 slice 来匹配 <code>hello</code> 的签名。没有 Deref 强制转换所有这些符号混在一起将更难以读写和理解。Deref 强制转换使得 Rust 自动的帮我们处理这些转换。</p>
<p>当所涉及到的类型定义了 <code>Deref</code> trait，Rust 会分析这些类型并使用任意多次 <code>Deref::deref</code> 调用以获得匹配参数的类型。这些解析都发生在编译时，所以利用 Deref 强制转换并没有运行时损耗！</p>
<h3 id="5-Deref-强制转换"><a href="#5-Deref-强制转换" class="headerlink" title="5.Deref 强制转换"></a>5.Deref 强制转换</h3><p>类似于如何使用 <code>Deref</code> trait 重载不可变引用的 <code>*</code> 运算符，Rust 提供了 <code>DerefMut</code> trait 用于重载可变引用的 <code>*</code> 运算符。</p>
<p>Rust 在发现类型和 trait 实现满足三种情况时会进行 Deref 强制转换：</p>
<ul>
<li>当 <code>T: Deref&lt;Target=U&gt;</code> 时从 <code>&amp;T</code> 到 <code>&amp;U</code>。</li>
<li>当 <code>T: DerefMut&lt;Target=U&gt;</code> 时从 <code>&amp;mut T</code> 到 <code>&amp;mut U</code>。</li>
<li>当 <code>T: Deref&lt;Target=U&gt;</code> 时从 <code>&amp;mut T</code> 到 <code>&amp;U</code>。</li>
</ul>
<p>头两个情况除了第二种实现了可变性之外是相同的：第一种情况表明如果有一个 &amp;T，而 T 实现了返回 U 类型的 Deref，则可以直接得到 &amp;U。第二种情况表明对于可变引用也有着相同的行为。 </p>
<p>第三个情况有些微妙：Rust 也会将可变引用强转为不可变引用。但是反之是 <strong>不可能</strong> 的：不可变引用永远也不能强转为可变引用。因为根据借用规则，如果有一个可变引用，其必须是这些数据的唯一引用（否则程序将无法编译）。将一个可变引用转换为不可变引用永远也不会打破借用规则。</p>
<h2 id="3-Drop-trait"><a href="#3-Drop-trait" class="headerlink" title="3 .Drop  trait"></a>3 .Drop  trait</h2><p>实现<code>Drop  trait</code>允许我们在值要离开作用域时执行一些代码，例如当 <code>Box&lt;T&gt;</code> 被丢弃时会释放 box 指向的堆空间。</p>
<p><code>Drop</code> trait 要求实现一个叫做 <code>drop</code> 的方法，它获取一个 <code>self</code> 的可变引用。</p>
<p>下面的代码展示了当其实例离开作用域时，打印出 <code>Dropping CustomPointer with data: {}</code> ，这会演示 Rust 何时运行 <code>drop</code> 函数：</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">struct</span> CustomPointer<span class="token punctuation">{</span>
    data<span class="token punctuation">:</span>String
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//实现 Drop trait </span>
<span class="token keyword">impl</span>  Drop <span class="token keyword">for</span> CustomPointer<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//实现drop方法</span>
    <span class="token keyword">fn</span> <span class="token function">drop</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//Drop trait 包含在 prelude 中，所以无需导入它。</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Dropping CustomPointer with data: {}"</span><span class="token punctuation">,</span><span class="token keyword">self</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> data1 <span class="token operator">=</span> CustomPointer<span class="token punctuation">{</span>data<span class="token punctuation">:</span> String<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"my data1"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">let</span> data2 <span class="token operator">=</span> CustomPointer<span class="token punctuation">{</span>data<span class="token punctuation">:</span> String<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"my data2"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//data2离开作用域会被先行删除</span>
    <span class="token keyword">let</span> data3 <span class="token operator">=</span> CustomPointer<span class="token punctuation">{</span>data<span class="token punctuation">:</span> String<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"my data3"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"CustomPointer has been Created!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果：</p>
<pre class="line-numbers language-bash"><code class="language-bash">Dropping CustomPointer with data: my data2
CustomPointer has been Created<span class="token operator">!</span>
Dropping CustomPointer with data: my data3
Dropping CustomPointer with data: my data1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>当实例离开作用域 Rust 会自动调用 <code>drop</code>，并调用我们指定的代码，这个例子的作用是给了我们一个 drop 方法如何工作的可视化指导。</p>
<h3 id="通过-std-mem-drop-提早丢弃值"><a href="#通过-std-mem-drop-提早丢弃值" class="headerlink" title="通过 std::mem::drop 提早丢弃值"></a>通过 <code>std::mem::drop</code> 提早丢弃值</h3><p>不幸的是，我们并不能直截了当的禁用 <code>drop</code> 这个功能。通常也不需要禁用 <code>drop</code> ；整个 <code>Drop</code> trait 存在的意义在于其是自动处理的。然而，有时你可能需要提早清理某个值。</p>
<p>一个例子是当使用智能指针管理锁时；你可能希望强制运行 <code>drop</code> 方法来释放锁以便作用域中的其他代码可以获取锁。Rust 并不允许我们主动调用 <code>Drop</code> trait 的 <code>drop</code> 方法。</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">test_drop_pre</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> pointer1 <span class="token operator">=</span> CustomPointer<span class="token punctuation">{</span>data<span class="token punctuation">:</span> String<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"my data1"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    pointer1<span class="token punctuation">.</span><span class="token function">drop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//explicit destructor calls not allowed</span>
    <span class="token keyword">let</span> pointer2 <span class="token operator">=</span> CustomPointer<span class="token punctuation">{</span>data<span class="token punctuation">:</span> String<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"my data2"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Prepare drop pointer1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出</p>
<pre class="line-numbers language-sh"><code class="language-sh">//explicit destructor calls not allowed<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>Rust 不允许我们显式调用 <code>drop</code> ,因为 Rust 会在 <code>main</code> 的结尾对值自动调用 <code>drop</code>，这会导致一个 <em>double free</em> 错误，因为 Rust 会尝试清理相同的值两次。</p>
<p>当我们希望在作用域结束之前就强制释放变量的话，我们应该使用的是由标准库提供的 <code>std::mem::drop</code>。</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">struct</span> CustomPointer<span class="token punctuation">{</span>
    data<span class="token punctuation">:</span>String
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> Drop <span class="token keyword">for</span> CustomPointer<span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">drop</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Dropping CustomPointer with data: {}"</span><span class="token punctuation">,</span><span class="token keyword">self</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">test_drop_pre</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> pointer1 <span class="token operator">=</span> CustomPointer<span class="token punctuation">{</span>data<span class="token punctuation">:</span> String<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"my data1"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">drop</span><span class="token punctuation">(</span>pointer1<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword">let</span> pointer2 <span class="token operator">=</span> CustomPointer<span class="token punctuation">{</span>data<span class="token punctuation">:</span> String<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"my data2"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Prepare drop pointer1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">test_drop_pre</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出</p>
<pre class="line-numbers language-shell"><code class="language-shell">Dropping CustomPointer with data: my data1
Prepare drop pointer1
Dropping CustomPointer with data: my data2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>Drop</code> trait 实现中指定的代码可以用于许多方面，来使得清理变得方便和安全：比如可以用其创建我们自己的内存分配器！通过 <code>Drop</code> trait 和 Rust 所有权系，你无需担心之后的代码清理，Rust 会自动考虑这些问题。</p>
<p>我们也无需担心意外的清理掉仍在使用的值，这会造成编译器错误：所有权系统确保引用总是有效的，也会确保 <code>drop</code> 只会在值不再被使用时被调用一次。</p>
<h2 id="4-Rc-lt-T-gt-引用计数智能指针"><a href="#4-Rc-lt-T-gt-引用计数智能指针" class="headerlink" title="4 .Rc<T>: 引用计数智能指针"></a>4 .<code>Rc&lt;T&gt;</code>: 引用计数智能指针</h2><p>大部分情况下所有权是非常明确的：可以准确地知道哪个变量拥有某个值。然而，有些情况单个值可能会有多个所有者。</p>
<p>例如，在图数据结构中，多个边可能指向相同的节点，而这个节点从概念上讲为所有指向它的边所拥有。节点在没有任何边指向它从而没有任何所有者之前，都不应该被清理掉。</p>
<p>为了启用多所有权需要显式地使用 Rust 类型 <code>Rc&lt;T&gt;</code>，其为 <strong>引用计数</strong>（<em>reference counting</em>）的缩写。引用计数意味着记录一个值的引用数量来知晓这个值是否仍在被使用。如果某个值有零个引用，就代表没有任何有效引用并可以被清理。</p>
<h4 id="Rc-lt-T-gt-适用于共享所有权"><a href="#Rc-lt-T-gt-适用于共享所有权" class="headerlink" title="Rc<T>适用于共享所有权"></a><code>Rc&lt;T&gt;</code>适用于共享所有权</h4><p><code>Rc&lt;T&gt;</code>用于当多个部分需要共享堆上的数据，但无法确定谁最后使用时。如果确实知道哪部分是最后一个结束使用的话，就可以令其成为数据的所有者，正常的所有权规则就可以在编译时生效。</p>
<ul>
<li>适用于<strong>单线程环境</strong>。</li>
</ul>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">enum</span> List <span class="token punctuation">{</span>
    <span class="token function">Cons</span><span class="token punctuation">(</span>i32<span class="token punctuation">,</span> Box<span class="token operator">&lt;</span>List<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    Nil<span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">use</span> <span class="token keyword">crate</span><span class="token punctuation">:</span><span class="token punctuation">:</span>List<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">{</span>Cons<span class="token punctuation">,</span> Nil<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token function">Cons</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> Box<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token function">Cons</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> Box<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>Nil<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token function">Cons</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> Box<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token function">Cons</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> Box<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在的数据结构将会变成：</p>
<p><img src="https://raw.githubusercontent.com/NoahChen1994/picgo/main/img/2025/0301155305(ms)/Rc%3CT%3E%E5%85%B1%E4%BA%AB%E6%89%80%E6%9C%89%E6%9D%831.png" alt="共享所有权"></p>
<p>尝试编译：</p>
<pre class="line-numbers language-shell"><code class="language-shell">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0382]: use of moved value: `a`
  --> src/main.rs:11:30
   |
9  |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
   |         - move occurs because `a` has type `List`, which does not implement the `Copy` trait
10 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
11 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `cons-list` (bin "cons-list") due to 1 previous error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>Cons</code> 成员拥有其储存的数据，所以当创建 <code>b</code> 列表时，<code>a</code> 被移动进了 <code>b</code> 这样 <code>b</code> 就拥有了 <code>a</code>。接着当再次尝试使用 <code>a</code> 创建 <code>c</code> 时，这不被允许，因为 <code>a</code> 的所有权已经被移动。</p>
<p>我们修改 <code>List</code> 的定义为使用 <code>Rc&lt;T&gt;</code> 代替 <code>Box&lt;T&gt;</code>。现在每一个 <code>Cons</code> 变量都包含一个值和一个指向 <code>List</code> 的 <code>Rc&lt;T&gt;</code>。</p>
<ul>
<li><p>当创建 <code>b</code> 时，不同于获取 <code>a</code> 的所有权，这里会克隆 <code>a</code> 所包含的 <code>Rc&lt;List&gt;</code>，这会将引用计数从 1 增加到 2 并允许 <code>a</code> 和 <code>b</code> 共享 <code>Rc&lt;List&gt;</code> 中数据的所有权。</p>
</li>
<li><p>创建 <code>c</code> 时也会克隆 <code>a</code>，这会将引用计数从 2 增加为 3。每次调用 <code>Rc::clone</code>，<code>Rc&lt;List&gt;</code> 中数据的引用计数都会增加，直到有零个引用之前其数据都不会被清理。</p>
</li>
</ul>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token keyword">crate</span><span class="token punctuation">:</span><span class="token punctuation">:</span>List<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">{</span>Cons<span class="token punctuation">,</span> Nil<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>rc<span class="token punctuation">:</span><span class="token punctuation">:</span>Rc<span class="token punctuation">;</span>
<span class="token keyword">enum</span> List <span class="token punctuation">{</span>
    <span class="token function">Cons</span><span class="token punctuation">(</span>i32<span class="token punctuation">,</span> Rc<span class="token operator">&lt;</span>List<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    Nil<span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> a <span class="token operator">=</span> Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token function">Cons</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token function">Cons</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>Nil<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token function">Cons</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token function">Cons</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也可以调用 <code>a.clone()</code> 而不是 <code>Rc::clone(&amp;a)</code>，不过在这里 Rust 的习惯是使用 <code>Rc::clone</code>。这是因为<code>Rc::clone</code> 的实现并不像大部分类型的 <code>clone</code> 实现那样对所有数据进行深拷贝,它只会增加引用计数，这并不会花费多少时间。</p>
<h4 id="克隆-Rc-会增加引用计数"><a href="#克隆-Rc-会增加引用计数" class="headerlink" title="克隆 Rc 会增加引用计数"></a>克隆 <code>Rc</code> 会增加引用计数</h4><p>以便将列表 <code>c</code> 置于内部作用域中，这样就可以观察当 <code>c</code> 离开作用域时引用计数如何变化。</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> a <span class="token operator">=</span> Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token function">Cons</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token function">Cons</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>Nil<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"a refrence count: {}"</span><span class="token punctuation">,</span>Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">strong_count</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//a refrence count: 1</span>
    <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token function">Cons</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span>Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"a refrence count: {}"</span><span class="token punctuation">,</span>Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">strong_count</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//a refrence count: 2</span>
    <span class="token punctuation">{</span>
    <span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token function">Cons</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span>Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"a refrence count: {}"</span><span class="token punctuation">,</span>Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">strong_count</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//a refrence count: 3</span>
    <span class="token punctuation">}</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"count after c goes out of scope: {}"</span><span class="token punctuation">,</span>Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">strong_count</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//count after c goes out of scope: 2</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>我们能够看到 <code>a</code> 中 <code>Rc&lt;List&gt;</code> 的初始引用计数为 1，接着每次调用 <code>clone</code>，计数会增加 1。</li>
<li>当 <code>c</code> 离开作用域时，计数减 1。不必像调用 <code>Rc::clone</code> 增加引用计数那样调用一个函数来减少计数；<code>Drop</code> trait 的实现使得 <code>Rc&lt;T&gt;</code> 的值离开作用域时自动减少引用计数。</li>
</ul>
<h2 id="5-RefCell-lt-T-gt-与内部可变性模式"><a href="#5-RefCell-lt-T-gt-与内部可变性模式" class="headerlink" title="5. RefCell<T> 与内部可变性模式"></a><strong>5. <code>RefCell&lt;T&gt;</code> 与内部可变性模式</strong></h2><p><strong>内部可变性（Interior Mutability）</strong> 是 Rust 提供的一种设计模式，它允许在<strong>不可变引用</strong>的情况下修改数据。通常，Rust 的借用规则不允许这种操作，而 <strong><code>RefCell&lt;T&gt;</code> 通过运行时检查借用规则</strong> 来实现这一特性。</p>
<h3 id="1-RefCell-lt-T-gt-与借用规则"><a href="#1-RefCell-lt-T-gt-与借用规则" class="headerlink" title="1. RefCell<T> 与借用规则"></a><strong>1. <code>RefCell&lt;T&gt;</code> 与借用规则</strong></h3><p>在 Rust 中，借用规则如下：</p>
<ul>
<li><strong>在任意时刻</strong>，只能有<strong>一个可变引用</strong> 或 <strong>多个不可变引用</strong>，但不能同时存在两者。</li>
<li><strong>引用必须始终有效</strong>。</li>
</ul>
<p><strong>区别：</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>借用检查</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>引用（&amp; / &amp;mut）</strong></td>
<td><strong>编译时</strong></td>
<td>静态借用检查，最安全</td>
</tr>
<tr>
<td><strong><code>Box&lt;T&gt;</code></strong></td>
<td><strong>编译时</strong></td>
<td>拥有数据的唯一所有权</td>
</tr>
<tr>
<td><strong><code>Rc&lt;T&gt;</code></strong></td>
<td><strong>编译时</strong>（仅不可变）</td>
<td>允许多个所有者，共享不可变数据</td>
</tr>
<tr>
<td><strong><code>RefCell&lt;T&gt;</code></strong></td>
<td><strong>运行时</strong></td>
<td>允许在不可变环境中修改数据</td>
</tr>
</tbody></table>
<p><strong>⚠️ 注意：</strong></p>
<ul>
<li>违反借用规则时，普通引用会<strong>导致编译错误</strong>，而 <code>RefCell&lt;T&gt;</code> 会在<strong>运行时报 panic</strong>。</li>
<li><code>RefCell&lt;T&gt;</code> <strong>适用于单线程</strong>，如果在多线程环境中需要内部可变性，应使用 <code>Mutex&lt;T&gt;</code> 或 <code>RwLock&lt;T&gt;</code>。</li>
</ul>
<h3 id="2-内部可变性：不可变值的可变借用"><a href="#2-内部可变性：不可变值的可变借用" class="headerlink" title="2.内部可变性：不可变值的可变借用"></a>2.内部可变性：不可变值的可变借用</h3><p>借用规则的一个推论是当有一个不可变值时，不能可变地借用它。例如，如下代码不能编译：</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> x<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//^^^^^^ cannot borrow as mutable</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>特定情况下，令一个值在其方法内部能够修改自身，而在其他代码中仍视为不可变，是很有用的。RefCell<t>` 是一个获得内部可变性的方法。它并没有完全绕开借用规则，编译器中的借用检查器允许内部可变性并相应地在运行时检查借用规则。</t></p>
<p>让我们通过一个实际的例子来探索何处可以使用 <code>RefCell&lt;T&gt;</code> 来修改不可变值并看看为何这么做是有意义的。</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>cell<span class="token punctuation">:</span><span class="token punctuation">:</span>RefCell<span class="token punctuation">;</span>

<span class="token keyword">struct</span> Counter <span class="token punctuation">{</span>
    value<span class="token punctuation">:</span> RefCell<span class="token operator">&lt;</span>i32<span class="token operator">></span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> Counter <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">*</span><span class="token keyword">self</span><span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">borrow_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 在不可变引用下修改数据</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">fn</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> i32 <span class="token punctuation">{</span>
        <span class="token operator">*</span><span class="token keyword">self</span><span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">borrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> counter <span class="token operator">=</span> Counter <span class="token punctuation">{</span> value<span class="token punctuation">:</span> RefCell<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    counter<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Counter: {}"</span><span class="token punctuation">,</span> counter<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出: Counter: 1</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>✅ <code>Counter</code> 结构体的 <code>self</code> <strong>是不可变的</strong>，但 <code>RefCell&lt;T&gt;</code> 允许在 <code>increment()</code> 方法中修改 <code>value</code>。</p>
<h3 id="3-RefCell-lt-T-gt-的典型应用：Mock-对象"><a href="#3-RefCell-lt-T-gt-的典型应用：Mock-对象" class="headerlink" title="3. RefCell<T> 的典型应用：Mock 对象"></a><strong>3. <code>RefCell&lt;T&gt;</code> 的典型应用：Mock 对象</strong></h3><p>在测试场景中，我们可能会用某个类型替换另一个类型，以便观察特定的行为并断言它是被正确实现的。这个占位符类型被称为 <strong>测试替身</strong>(<em>test double</em>)。它被用于在运行测试时替代某个类型。</p>
<p><strong>mock 对象</strong> 是特定类型的测试替身，它们记录测试过程中发生了什么以便可以断言操作是正确的。</p>
<p>如下是一个我们想要测试的场景：我们在编写一个记录某个值与最大值的差距的库，并根据当前值与最大值的差距来发送消息。例如，这个库可以用于记录用户所允许的 API 调用数量限额。</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token comment" spellcheck="true">// 定义一个 MsgSender trait，指定任何实现该 trait 的类型都必须具备发送消息的能力</span>
<span class="token comment" spellcheck="true">// trait 是 Rust 中的接口，定义了一组方法签名</span>
<span class="token keyword">pub</span> <span class="token keyword">trait</span> MsgSender <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// sendMsg 方法接收不可变引用 &amp;self 和一个字符串切片 &amp;str，用于发送消息</span>
    <span class="token keyword">fn</span> <span class="token function">sendMsg</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> msg<span class="token punctuation">:</span> <span class="token operator">&amp;</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 定义 Tracker 结构体，用于追踪值并根据条件发送消息</span>
<span class="token comment" spellcheck="true">// 使用泛型 T 表示消息发送者的类型，T 必须实现 MsgSender trait</span>
<span class="token comment" spellcheck="true">// 生命周期参数 'a 表示 sender 引用的生命周期</span>
<span class="token keyword">pub</span> <span class="token keyword">struct</span> Tracker<span class="token operator">&lt;</span>'a<span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token punctuation">{</span>
    sender<span class="token punctuation">:</span> <span class="token operator">&amp;</span>'a T<span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 指向消息发送者的引用，带有生命周期 'a，确保引用有效</span>
    value<span class="token punctuation">:</span> usize<span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">// 当前值，表示已经使用的量</span>
    max<span class="token punctuation">:</span> usize<span class="token punctuation">,</span>     <span class="token comment" spellcheck="true">// 最大允许值，表示配额上限</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 为 Tracker 实现方法，适用于任何生命周期 'a 和类型 T，其中 T 需实现 MsgSender trait</span>
<span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token string">'a, T> Tracker&lt;'</span>a<span class="token punctuation">,</span> T<span class="token operator">></span> 
<span class="token keyword">where</span> 
    T<span class="token punctuation">:</span> MsgSender 
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 创建新的 Tracker 实例</span>
    <span class="token comment" spellcheck="true">// 参数 sender 是 T 类型的引用，max 是最大值</span>
    <span class="token comment" spellcheck="true">// 返回一个新的 Tracker 实例，初始值为 0</span>
    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">new</span><span class="token punctuation">(</span>sender<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token string">'a T, max: usize) -> Tracker&lt;'</span>a<span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 注意：返回类型应为 Tracker&lt;'a, T></span>
        Tracker <span class="token punctuation">{</span>
            sender<span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">// 存储传入的发送者引用</span>
            value<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 初始化当前值为 0</span>
            max<span class="token punctuation">,</span>      <span class="token comment" spellcheck="true">// 设置最大值</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 检查当前值并根据百分比发送消息</span>
    <span class="token comment" spellcheck="true">// &amp;mut self 表示需要可变引用以修改 value 字段</span>
    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function">check_and_send_msg</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> usize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 更新当前值</span>
        <span class="token comment" spellcheck="true">// 将 value 和 max 转换为 f64 类型，计算使用百分比</span>
        <span class="token keyword">let</span> percentage <span class="token operator">=</span> value <span class="token keyword">as</span> f64 <span class="token operator">/</span> <span class="token keyword">self</span><span class="token punctuation">.</span>max <span class="token keyword">as</span> f64<span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 根据百分比决定发送什么消息</span>
        <span class="token keyword">if</span> percentage <span class="token operator">></span> <span class="token number">1.0</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 如果超过 100%，直接打印超额警告，不使用 sender</span>
            <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Over ur quota: {}!"</span><span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>max<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 如果未超额，使用 sender 发送一条消息</span>
            <span class="token keyword">self</span><span class="token punctuation">.</span>sender<span class="token punctuation">.</span><span class="token function">sendMsg</span><span class="token punctuation">(</span><span class="token string">"Send a msg!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 测试模块，仅在运行测试时编译</span>
<span class="token attribute attr-name">#[cfg(test)]</span>
<span class="token keyword">mod</span> tests <span class="token punctuation">{</span>
    <span class="token keyword">use</span> <span class="token keyword">super</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">*</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 引入父模块中的所有项</span>
    <span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>cell<span class="token punctuation">:</span><span class="token punctuation">:</span>RefCell<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 引入 RefCell，用于在不可变上下文修改数据</span>

    <span class="token comment" spellcheck="true">// 定义 MockMsg 结构体，用于模拟消息发送并记录发送的消息</span>
    <span class="token keyword">struct</span> MockMsg <span class="token punctuation">{</span>
        sent_msgs<span class="token punctuation">:</span> RefCell<span class="token operator">&lt;</span>Vec<span class="token operator">&lt;</span>String<span class="token operator">>></span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 使用 RefCell 包裹 Vec，提供内部可变性</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">impl</span> MockMsg <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 创建新的 MockMsg 实例</span>
        <span class="token keyword">fn</span> <span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> MockMsg <span class="token punctuation">{</span>
            MockMsg <span class="token punctuation">{</span>
                sent_msgs<span class="token punctuation">:</span> RefCell<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token function">vec!</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 初始化一个空的消息向量</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 为 MockMsg 实现 MsgSender trait</span>
    <span class="token keyword">impl</span> MsgSender <span class="token keyword">for</span> MockMsg <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// sendMsg 方法模拟发送消息并记录</span>
        <span class="token comment" spellcheck="true">// &amp;self 表示不可变引用，通过 RefCell 实现内部修改</span>
        <span class="token keyword">fn</span> <span class="token function">sendMsg</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> msg<span class="token punctuation">:</span> <span class="token operator">&amp;</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"MsgSender for MockMsg send: {}"</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 打印消息，模拟发送行为</span>
            <span class="token comment" spellcheck="true">// 使用 borrow_mut 获取 Vec 的可变引用，将消息存入 sent_msgs</span>
            <span class="token keyword">self</span><span class="token punctuation">.</span>sent_msgs<span class="token punctuation">.</span><span class="token function">borrow_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>String<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">from</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 测试用例：验证 Tracker 在未超额时是否正确发送消息</span>
    <span class="token attribute attr-name">#[test]</span>
    <span class="token keyword">fn</span> <span class="token function">it_work</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> msg <span class="token operator">=</span> MockMsg<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 创建一个 MockMsg 实例，用于模拟消息发送</span>
        <span class="token keyword">let</span> <span class="token keyword">mut</span> tracker <span class="token operator">=</span> Tracker<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>msg<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 创建 Tracker 实例，最大值为 100，借用 msg</span>
        tracker<span class="token punctuation">.</span><span class="token function">check_and_send_msg</span><span class="token punctuation">(</span><span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 设置值为 80（80/100 = 0.8，未超额）</span>
        <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> msg<span class="token punctuation">.</span>sent_msgs<span class="token punctuation">.</span><span class="token function">borrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于 <code>RefCell&lt;T&gt;</code> 来说， <code>borrow</code> 和 <code>borrow_mut</code> 方法是 <code>RefCell&lt;T&gt;</code> 安全 API中 的一部分。</p>
<ul>
<li><code>borrow</code> 方法返回 <code>Ref&lt;T&gt;</code> 类型的智能指针，</li>
<li><code>borrow_mut</code> 方法返回 <code>RefMut&lt;T&gt;</code> 类型的智能指针。</li>
<li>这两个类型都实现了 <code>Deref</code>，所以可以当作常规引用对待。</li>
</ul>
<p><code>RefCell&lt;T&gt;</code> 记录当前有多少个活动的 <code>Ref&lt;T&gt;</code> 和 <code>RefMut&lt;T&gt;</code> 智能指针。每次调用 <code>borrow</code>，<code>RefCell&lt;T&gt;</code> 将活动的不可变借用计数加一。当 <code>Ref&lt;T&gt;</code> 值离开作用域时，不可变借用计数减一。就像编译时借用规则一样，<code>RefCell&lt;T&gt;</code> 在<strong>任何时候只允许有多个不可变借用或一个可变借用</strong>。</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>cell<span class="token punctuation">:</span><span class="token punctuation">:</span>RefCell<span class="token punctuation">;</span>

<span class="token keyword">struct</span> MyStruct <span class="token punctuation">{</span>
    value<span class="token punctuation">:</span> RefCell<span class="token operator">&lt;</span>i32<span class="token operator">></span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> MyStruct <span class="token punctuation">{</span> value<span class="token punctuation">:</span> RefCell<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> a <span class="token operator">=</span> x<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">borrow_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> b <span class="token operator">=</span> x<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">borrow_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>a <span class="token operator">+=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>b <span class="token operator">+=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"Value: {}"</span><span class="token punctuation">,</span> x<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">borrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果</p>
<pre class="line-numbers language-shell"><code class="language-shell">thread 'main' panicked at .\main.rs:11:25:
already borrowed: BorrowMutError<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>注意代码 panic 和信息 <code>already borrowed: BorrowMutError</code>。这也就是 <code>RefCell&lt;T&gt;</code> 如何在运行时处理违反借用规则的情况。</p>
<h3 id="4-注意事项："><a href="#4-注意事项：" class="headerlink" title="4.注意事项："></a>4.注意事项：</h3><p>虽然它成功通过了编译，但是却把潜在错误后置了，甚至有可能发布到生产环境才会发现。还会因为在运行时而不是编译时记录借用而导致少量的运行时性能惩罚。然而，使用 <code>RefCell</code> 使得在只允许不可变值的上下文中编写修改自身以记录消息的 mock 对象成为可能。虽然有取舍，但是我们可以选择使用 <code>RefCell&lt;T&gt;</code> 来获得比常规引用所能提供的更多的功能。</p>
<h3 id="5-Rc-和-RefCell-结合使用"><a href="#5-Rc-和-RefCell-结合使用" class="headerlink" title="5.Rc 和 RefCell 结合使用"></a>5.Rc 和 RefCell 结合使用</h3><p><code>RefCell&lt;T&gt;</code> 的一个常见用法是与 <code>Rc&lt;T&gt;</code> 结合。回忆一下 <code>Rc&lt;T&gt;</code> 允许对相同数据有多个所有者，不过只能提供数据的不可变访问。如果有一个储存了 <code>RefCell&lt;T&gt;</code> 的 <code>Rc&lt;T&gt;</code> 的话，就可以得到有多个所有者 <strong>并且</strong> 可以修改的值了！</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token attribute attr-name">#[derive(Debug)]</span>
<span class="token keyword">enum</span> List <span class="token punctuation">{</span>
    <span class="token function">Cons</span><span class="token punctuation">(</span>Rc<span class="token operator">&lt;</span>RefCell<span class="token operator">&lt;</span>i32<span class="token operator">>></span><span class="token punctuation">,</span> Rc<span class="token operator">&lt;</span>List<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//Cons(当前节点可共享可修改的值, 可共享的下一个节点的指针)：</span>
    Nil<span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">use</span> <span class="token keyword">crate</span><span class="token punctuation">:</span><span class="token punctuation">:</span>List<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">{</span>Cons<span class="token punctuation">,</span> Nil<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>cell<span class="token punctuation">:</span><span class="token punctuation">:</span>RefCell<span class="token punctuation">;</span>
<span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>rc<span class="token punctuation">:</span><span class="token punctuation">:</span>Rc<span class="token punctuation">;</span>

<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//// 创建一个共享的值 5</span>
    <span class="token keyword">let</span> value <span class="token operator">=</span> Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>RefCell<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 创建链表 a: [5, Nil]，因为要共享给b、c所以用Rc::new()包裹起来</span>
    <span class="token keyword">let</span> a <span class="token operator">=</span> Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token function">Cons</span><span class="token punctuation">(</span>Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span> Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>Nil<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 创建链表 b: [3, a]</span>
    <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token function">Cons</span><span class="token punctuation">(</span>Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>RefCell<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 创建链表 c: [4, a]</span>
    <span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token function">Cons</span><span class="token punctuation">(</span>Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>RefCell<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 修改 value 的值，从 5 变成 15</span>
    <span class="token operator">*</span>value<span class="token punctuation">.</span><span class="token function">borrow_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+=</span> <span class="token number">10</span><span class="token punctuation">;</span>

    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"a after = {a:?}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"b after = {b:?}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"c after = {c:?}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>运行结果</strong></p>
<pre class="line-numbers language-shell"><code class="language-shell">a after = Cons(RefCell { value: 15 }, Nil)
b after = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
c after = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="6-引用循环与内存泄漏"><a href="#6-引用循环与内存泄漏" class="headerlink" title="6. 引用循环与内存泄漏"></a>6. 引用循环与内存泄漏</h2><p>Rust 的内存安全机制让开发者很难制造出无法清理的内存（也就是所谓的<code>内存泄漏(memory leak)</code>），但这并非完全不可能。Rust 并不保证完全防止内存泄漏，因此在 Rust 中，内存泄漏被视为内存安全的一种情况。例如，通过使用 <code>Rc&lt;T&gt;</code>和 <code>RefCell&lt;T&gt;</code>，可以构造出引用循环。这种情况下，引用计数永远不会降至 0，导致所持有的数据无法被释放，从而引发内存泄漏。</p>
<h4 id="1-引用循环造成内存泄漏："><a href="#1-引用循环造成内存泄漏：" class="headerlink" title="1.引用循环造成内存泄漏："></a>1.引用循环造成内存泄漏：</h4><pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>rc<span class="token punctuation">:</span><span class="token punctuation">:</span>Rc<span class="token punctuation">;</span>
<span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>cell<span class="token punctuation">:</span><span class="token punctuation">:</span>RefCell<span class="token punctuation">;</span>
<span class="token keyword">use</span> <span class="token keyword">crate</span><span class="token punctuation">:</span><span class="token punctuation">:</span>List<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">{</span>Cons<span class="token punctuation">,</span> Nil<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token attribute attr-name">#[derive(Debug)]</span>
<span class="token keyword">enum</span> List<span class="token punctuation">{</span>
    <span class="token function">Cons</span><span class="token punctuation">(</span>i32<span class="token punctuation">,</span> RefCell<span class="token operator">&lt;</span>Rc<span class="token operator">&lt;</span>List<span class="token operator">>></span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    Nil
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> List <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 返回节点的下一个节点</span>
    <span class="token keyword">fn</span> <span class="token function">tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> Option<span class="token operator">&lt;</span><span class="token operator">&amp;</span>RefCell<span class="token operator">&lt;</span>Rc<span class="token operator">&lt;</span>List<span class="token operator">>></span><span class="token operator">></span><span class="token punctuation">{</span>
        <span class="token keyword">match</span> <span class="token keyword">self</span> <span class="token punctuation">{</span>
            <span class="token function">Cons</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span>item<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span><span class="token function">Some</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">,</span>
            Nil <span class="token operator">=</span><span class="token operator">></span> None
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 创建节点 a，值为 5，下一个节点为 Nil</span>
    <span class="token keyword">let</span> a <span class="token operator">=</span> Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token function">Cons</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> RefCell<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>Nil<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"a initial rc count = {}"</span><span class="token punctuation">,</span> Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">strong_count</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//a initial rc count = 1</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"a next item = {:?}"</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span><span class="token function">tail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//a next item = Some(RefCell { value: Nil })</span>

    <span class="token comment" spellcheck="true">// 创建节点 b，值为 6，下一个节点指向 a</span>
    <span class="token keyword">let</span> b <span class="token operator">=</span> Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token function">Cons</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> RefCell<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"a rc count after b creation = {}"</span><span class="token punctuation">,</span> Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">strong_count</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//a rc count after b creation = 2</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"b initial rc count = {}"</span><span class="token punctuation">,</span> Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">strong_count</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//b initial rc count = 1</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"b next item = {:?}"</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span><span class="token function">tail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })</span>

    <span class="token comment" spellcheck="true">// 修改 a 的下一个节点，使其指向 b，形成引用循环</span>
    <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token function">Some</span><span class="token punctuation">(</span>link<span class="token punctuation">)</span> <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">tail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token operator">*</span>link<span class="token punctuation">.</span><span class="token function">borrow_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"b rc count after changing a = {}"</span><span class="token punctuation">,</span> Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">strong_count</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//b rc count after changing a = 2</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"a rc count after changing a = {}"</span><span class="token punctuation">,</span> Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">strong_count</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//a rc count after changing a = 2</span>

    <span class="token comment" spellcheck="true">// 由于 a 和 b 互相引用，递归打印会导致栈溢出</span>
    <span class="token comment" spellcheck="true">//println!("a next item = {:?}", a.tail());</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到将列表 <code>a</code> 修改为指向 <code>b</code> 之后， <code>a</code> 和 <code>b</code> 中的 <code>Rc&lt;List&gt;</code> 实例的引用计数都是 2。在 <code>main</code> 的结尾，Rust 丢弃 <code>b</code>，这会使 <code>b</code> <code>Rc&lt;List&gt;</code> 实例的引用计数从 2 减为 1。然而，<code>b</code> <code>Rc&lt;List&gt;</code> 不能被回收，因为其引用计数是 1 而不是 0。接下来 Rust 会丢弃 <code>a</code> 将 <code>a</code> <code>Rc&lt;List&gt;</code> 实例的引用计数从 2 减为 1。这个实例也不能被回收，因为 <code>b</code> <code>Rc&lt;List&gt;</code> 实例依然引用它，所以其引用计数是 1。这些列表的内存将永远保持未被回收的状态</p>
<h4 id="2-避免引用循环"><a href="#2-避免引用循环" class="headerlink" title="2.避免引用循环"></a>2.避免引用循环</h4><p>可以通过调用 <code>Rc::downgrade</code> 并传递 <code>Rc&lt;T&gt;</code> 实例的引用来创建其值的 <strong>弱引用</strong>（<em>weak reference</em>）。</p>
<h5 id="Weak（弱引用）"><a href="#Weak（弱引用）" class="headerlink" title="Weak（弱引用）"></a>Weak<t>（弱引用）</t></h5><ul>
<li>由 <code>Rc::downgrade</code> 创建，不增加 <code>strong_count</code>，而是增加 <code>weak_count</code>（弱引用计数）。</li>
<li>通过 <code>upgrade</code> 方法转换为 <code>Option&lt;Rc&lt;T&gt;&gt;</code>，如果数据仍然存在，则返回 <code>Some(Rc&lt;T&gt;)</code>，否则返回 <code>None</code>。</li>
</ul>
<p>强引用代表如何共享 <code>Rc&lt;T&gt;</code> 实例的所有权。弱引用并不属于所有权关系，当 <code>Rc&lt;T&gt;</code> 实例被清理时其计数没有影响。它们不会造成引用循环，因为任何涉及弱引用的循环会在其相关的值的强引用计数为 0 时被打断。</p>
<p><strong>父节点和子节点的双向引用</strong></p>
<ul>
<li>在树结构中，<strong>父节点拥有子节点</strong>，但<strong>子节点不应拥有父节点</strong>。</li>
<li>否则会形成循环引用，导致 <code>Rc&lt;T&gt;</code> 的 <code>strong_count</code> 永远不会归零，造成内存泄漏。</li>
</ul>
<h5 id="使用Weak引用父节点"><a href="#使用Weak引用父节点" class="headerlink" title="使用Weak引用父节点"></a>使用Weak<t>引用父节点</t></h5><ul>
<li><strong>父节点使用</strong> <code>**Rc&lt;T&gt;**</code> <strong>共享子节点的所有权</strong>。</li>
<li><strong>子节点使用</strong> <code>**Weak&lt;T&gt;**</code> <strong>弱引用父节点</strong>，这样当 <code>Rc&lt;T&gt;</code> 的 <code>strong_count == 0</code> 时，节点仍然可以被正确回收。</li>
</ul>
<p>下面这段代码通过 <code>Rc</code> 和 <code>Weak</code>构建了一个简单的父子树结构，展示了如何使用弱引用避免引用循环</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">{</span>Rc<span class="token punctuation">,</span> Weak<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 引入 Rc（强引用计数）和 Weak（弱引用计数）</span>
<span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>cell<span class="token punctuation">:</span><span class="token punctuation">:</span>RefCell<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 引入 RefCell，提供内部可变性</span>

<span class="token comment" spellcheck="true">// 定义一个树节点结构体，支持调试输出</span>
<span class="token attribute attr-name">#[derive(Debug)]</span>
<span class="token keyword">struct</span> Node <span class="token punctuation">{</span>
    value<span class="token punctuation">:</span> i32<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 节点的值</span>
    parent<span class="token punctuation">:</span> RefCell<span class="token operator">&lt;</span>Weak<span class="token operator">&lt;</span>Node<span class="token operator">>></span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 指向父节点的弱引用，使用 RefCell 包裹以允许运行时修改</span>
    child<span class="token punctuation">:</span> RefCell<span class="token operator">&lt;</span>Vec<span class="token operator">&lt;</span>Rc<span class="token operator">&lt;</span>Node<span class="token operator">>></span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 子节点列表，使用 Vec&lt;Rc&lt;Node>> 表示多个子节点，RefCell 提供可变性</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 测试函数，展示树结构的创建和弱引用的使用</span>
<span class="token keyword">fn</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 创建叶子节点 leaf，值为 5，无父节点，子节点为空</span>
    <span class="token keyword">let</span> leaf <span class="token operator">=</span> Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>Node <span class="token punctuation">{</span>
        value<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span>
        parent<span class="token punctuation">:</span> RefCell<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>Weak<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 初始时父节点为空弱引用（Weak::new()）</span>
        child<span class="token punctuation">:</span> RefCell<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token function">vec!</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 初始时子节点为空向量</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 打印 leaf 的父节点，尝试通过 upgrade 将 Weak 转换为 Rc</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"leaf parent is: {:?}"</span><span class="token punctuation">,</span> leaf<span class="token punctuation">.</span>parent<span class="token punctuation">.</span><span class="token function">borrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">upgrade</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token comment" spellcheck="true">// 输出: leaf parent is: None（因为 Weak::new() 表示没有指向任何节点）</span>

    <span class="token comment" spellcheck="true">// 创建分支节点 branch，值为 8，无父节点，子节点包含 leaf</span>
    <span class="token keyword">let</span> branch <span class="token operator">=</span> Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>Node <span class="token punctuation">{</span>
        value<span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">,</span>
        parent<span class="token punctuation">:</span> RefCell<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>Weak<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 初始时父节点为空弱引用</span>
        child<span class="token punctuation">:</span> RefCell<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token function">vec!</span><span class="token punctuation">[</span>Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>leaf<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 子节点包含 leaf 的强引用</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 修改 leaf 的父节点，使其指向 branch（使用弱引用）</span>
    <span class="token operator">*</span>leaf<span class="token punctuation">.</span>parent<span class="token punctuation">.</span><span class="token function">borrow_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">downgrade</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>branch<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将 branch 的弱引用赋值给 leaf 的 parent</span>
    <span class="token comment" spellcheck="true">// 注意：这里 leaf 的父节点被设置为 branch 的弱引用，而不是强引用，避免循环</span>

    <span class="token comment" spellcheck="true">// 再次打印 leaf 的父节点，检查弱引用是否有效</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"leaf parent is: {:?}"</span><span class="token punctuation">,</span> leaf<span class="token punctuation">.</span>parent<span class="token punctuation">.</span><span class="token function">borrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">upgrade</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 输出: leaf parent is: Some(Node { value: 8, parent: RefCell { value: (Weak) }, child: RefCell { value: [Node { value: 5, ... }] } })</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 主函数，调用测试函数</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>Rc 和 Weak 的作用</strong>:</p>
<ul>
<li><code>Rc&lt;T&gt;</code>: 允许多个所有者共享同一个值，跟踪强引用计数。</li>
<li><code>Weak&lt;T&gt;</code>: 弱引用不会影响值的释放，用于打破潜在的引用循环。</li>
<li><code>Rc::downgrade</code>: 将 <code>Rc</code>转换为 <code>Weak</code>，用于设置弱引用。</li>
<li><code>Weak::upgrade</code>: 将<code>Weak</code>转换为<code>Option&lt;Rc&lt;T&gt;&gt;</code>，检查引用的值是否仍然存在。</li>
</ul>
<p>如果<code>leaf.parent</code> 使用的是 <code>Rc&lt;Node&gt;（强引用）</code>而不是 <code>Weak&lt;Node&gt;</code>，则 branch 和 leaf 会互相强引用，形成循环：</p>
<ul>
<li><code>branch.child</code>持有 leaf 的强引用。</li>
<li><code>leaf.parent</code>持有 branch 的强引用。</li>
<li>结果：两者的强引用计数永远不会降为 0，内存无法释放。</li>
</ul>
<p>使用 Weak<node> 打破了这种循环，leaf 对 branch 的引用不影响 branch 的释放。</node></p>
<h4 id="3-观察strong-count和-weak-count的变化"><a href="#3-观察strong-count和-weak-count的变化" class="headerlink" title="3.观察strong_count和 weak_count的变化"></a>3.观察strong_count和 weak_count的变化</h4><pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">{</span>Rc<span class="token punctuation">,</span> Weak<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">use</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>cell<span class="token punctuation">:</span><span class="token punctuation">:</span>RefCell<span class="token punctuation">;</span>

<span class="token attribute attr-name">#[derive(Debug)]</span>
<span class="token keyword">struct</span> Node<span class="token punctuation">{</span>
    value<span class="token punctuation">:</span> i32<span class="token punctuation">,</span>
    parent<span class="token punctuation">:</span> RefCell<span class="token operator">&lt;</span>Weak<span class="token operator">&lt;</span>Node<span class="token operator">>></span><span class="token punctuation">,</span>
    child<span class="token punctuation">:</span> RefCell<span class="token operator">&lt;</span>Vec<span class="token operator">&lt;</span>Rc<span class="token operator">&lt;</span>Node<span class="token operator">>></span><span class="token operator">></span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">let</span> leaf <span class="token operator">=</span> Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>Node <span class="token punctuation">{</span>
        value<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span>
        parent<span class="token punctuation">:</span> RefCell<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>Weak<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        child<span class="token punctuation">:</span> RefCell<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token function">vec!</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">println!</span><span class="token punctuation">(</span>
        <span class="token string">"leaf strong = {}, weak = {}"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//leaf strong = 1, weak = 0</span>
        Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">strong_count</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>leaf<span class="token punctuation">)</span><span class="token punctuation">,</span>
        Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">weak_count</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>leaf<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">{</span>
        <span class="token keyword">let</span> branch <span class="token operator">=</span> Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>Node <span class="token punctuation">{</span>
            value<span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">,</span>
            parent<span class="token punctuation">:</span> RefCell<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>Weak<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            child<span class="token punctuation">:</span> RefCell<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token function">vec!</span><span class="token punctuation">[</span>Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>leaf<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token operator">*</span>leaf<span class="token punctuation">.</span>parent<span class="token punctuation">.</span><span class="token function">borrow_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">downgrade</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>branch<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">println!</span><span class="token punctuation">(</span>
            <span class="token string">"branch strong = {}, weak = {}"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//branch strong = 1, weak = 1</span>
            Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">strong_count</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>branch<span class="token punctuation">)</span><span class="token punctuation">,</span>
            Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">weak_count</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>branch<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">println!</span><span class="token punctuation">(</span>
            <span class="token string">"leaf strong = {}, weak = {}"</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//leaf strong = 2, weak = 0</span>
            Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">strong_count</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>leaf<span class="token punctuation">)</span><span class="token punctuation">,</span>
            Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">weak_count</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>leaf<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"leaf parent = {:?}"</span><span class="token punctuation">,</span> leaf<span class="token punctuation">.</span>parent<span class="token punctuation">.</span><span class="token function">borrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">upgrade</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//leaf parent = None</span>
    <span class="token function">println!</span><span class="token punctuation">(</span>
        <span class="token string">"leaf strong = {}, weak = {}"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//leaf strong = 1, weak = 0</span>
        Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">strong_count</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>leaf<span class="token punctuation">)</span><span class="token punctuation">,</span>
        Rc<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">weak_count</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>leaf<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="执行流程和计数变化"><a href="#执行流程和计数变化" class="headerlink" title="执行流程和计数变化"></a>执行流程和计数变化</h5><h6 id="1-创建-leaf"><a href="#1-创建-leaf" class="headerlink" title="1. 创建 leaf"></a><strong>1. 创建 leaf</strong></h6><p><code>let leaf = Rc::new(Node { ... });</code> </p>
<ul>
<li>leaf 是 Rc<node> 的唯一持有者。</node></li>
<li>强引用计数（Rc::strong_count(&amp;leaf)）为 1。</li>
<li>弱引用计数（Rc::weak_count(&amp;leaf)）为 0，因为没有弱引用指向它。</li>
<li>leaf.parent 是 Weak::new()，不指向任何节点。</li>
</ul>
<h6 id="2-创建-branch（内部作用域开始）"><a href="#2-创建-branch（内部作用域开始）" class="headerlink" title="2. 创建 branch（内部作用域开始）"></a><strong>2. 创建 branch（内部作用域开始）</strong></h6><p><code>let branch = Rc::new(Node {    value: 8,    parent: RefCell::new(Weak::new()),    child: RefCell::new(vec![Rc::clone(&amp;leaf)]), });</code> </p>
<ul>
<li>branch 是 Rc<node> 的唯一持有者，强引用计数为 1，弱引用计数为 0。</node></li>
<li>branch.child 包含 leaf 的强引用（通过 Rc::clone(&amp;leaf)），使 leaf 的强引用计数从 1 增加到 2。</li>
<li>leaf 的弱引用计数仍为 0。</li>
<li>leaf: 强引用 = 2（leaf 自身 + branch.child），弱引用 = 0。</li>
<li>branch: 强引用 = 1（branch 自身），弱引用 = 0。</li>
</ul>
<h6 id="3-修改-leaf-parent-指向-branch"><a href="#3-修改-leaf-parent-指向-branch" class="headerlink" title="3. 修改 leaf.parent 指向 branch"></a><strong>3. 修改 leaf.parent 指向 branch</strong></h6><p><code>*leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);</code></p>
<ul>
<li>Rc::downgrade(&amp;branch) 创建 branch 的弱引用，赋值给 leaf.parent。</li>
<li>branch 的弱引用计数增加到 1（来自 leaf.parent）。</li>
<li>branch 的强引用计数仍为 1（仅由 branch 持有）。</li>
<li>leaf 的强引用计数仍为 2，弱引用计数仍为 0（因为 Weak 不影响 leaf 的计数）。</li>
<li>branch: 强引用 = 1，弱引用 = 1。</li>
<li>leaf: 强引用 = 2，弱引用 = 0。</li>
</ul>
<h6 id="4-branch-离开作用域"><a href="#4-branch-离开作用域" class="headerlink" title="4. branch 离开作用域"></a><strong>4. branch 离开作用域</strong></h6><ul>
<li><strong>代码</strong>: 内部作用域 } 结束，branch 被销毁。<ul>
<li>branch 的强引用计数从 1 减少到 0，触发 Rc 的 Drop 实现，释放 branch 的 Node。</li>
<li>branch.child 中的 Rc<node>（指向 leaf）也被释放，leaf 的强引用计数从 2 减少到 1。</node></li>
<li>leaf.parent 中的弱引用（指向 branch）变得无效，因为 branch 已销毁。</li>
<li>leaf 的弱引用计数仍为 0。</li>
<li>leaf: 强引用 = 1（仅由 leaf 持有），弱引用 = 0。</li>
</ul>
</li>
</ul>
<h6 id="5-检查-leaf-parent-和最终状态"><a href="#5-检查-leaf-parent-和最终状态" class="headerlink" title="5. 检查 leaf.parent 和最终状态"></a><strong>5. 检查 leaf.parent 和最终状态</strong></h6><p><code>println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());</code></p>
<ul>
<li>leaf.parent.borrow().upgrade() 尝试将弱引用转换为 Rc<node>。</node></li>
<li>因为 branch 已销毁，弱引用无效，upgrade 返回 None。<br><code>leaf parent = None</code><br><code>println!("leaf strong = {}, weak = {}", Rc::strong_count(&amp;leaf), Rc::weak_count(&amp;leaf));</code></li>
<li>leaf 的强引用计数为 1（仅由 leaf 持有），弱引用计数为 0。</li>
</ul>
<p>一旦创建了 <code>leaf</code>，其 <code>Rc&lt;Node&gt;</code> 的强引用计数为 1，弱引用计数为 0。在内部作用域中创建了 <code>branch</code> 并与 <code>leaf</code> 相关联，此时 <code>branch</code> 中 <code>Rc&lt;Node&gt;</code> 的强引用计数为 1，弱引用计数为 1（因为 <code>leaf.parent</code> 通过 <code>Weak&lt;Node&gt;</code> 指向 <code>branch</code>）。这里 <code>leaf</code> 的强引用计数为 2，因为现在 <code>branch</code> 的 <code>branch.children</code> 中储存了 <code>leaf</code> 的 <code>Rc&lt;Node&gt;</code> 的拷贝，不过弱引用计数仍然为 0。</p>
<p>当内部作用域结束时，<code>branch</code> 离开作用域，<code>Rc&lt;Node&gt;</code> 的强引用计数减少为 0，所以其 <code>Node</code> 被丢弃。来自 <code>leaf.parent</code> 的弱引用计数 1 与 <code>Node</code> 是否被丢弃无关，所以并没有产生任何内存泄漏！</p>
<p>如果在内部作用域结束后尝试访问 <code>leaf</code> 的父节点，会再次得到 <code>None</code>。在程序的结尾，<code>leaf</code> 中 <code>Rc&lt;Node&gt;</code> 的强引用计数为 1，弱引用计数为 0，因为现在 <code>leaf</code> 又是 <code>Rc&lt;Node&gt;</code> 唯一的引用了。</p>
<p>所有这些管理计数和值的逻辑都内建于 <code>Rc&lt;T&gt;</code> 和 <code>Weak&lt;T&gt;</code> 以及它们的 <code>Drop</code> trait 实现中。通过在 <code>Node</code> 定义中指定从子节点到父节点的关系为一个<code>Weak&lt;T&gt;</code>引用，就能够拥有父节点和子节点之间的双向引用而不会造成引用循环和内存泄漏。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                           
                        </div>
                    
                </div>
                <div class="post_share"
                     style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
            <div class="article col s12 m6" data-aos="fade-up">
                <div class="article-badge left-badge text-color">
                    <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
                <div class="card">
                    <a href="/2025/03/02/rustzhong-de-bing-fa-bian-cheng/">
                        <div class="card-image">
                            
                                
                                <img src="/medias/featureimages/21.jpg" class="responsive-img" alt="Rust中的并发编程">
                            
                            <span class="card-title">Rust中的并发编程</span>
                        </div>
                    </a>
                    <div class="card-content article-content">
                        <div class="summary block-with-text">
                            
                                1 .线程（Threads）在大部分现代操作系统中，已执行程序的代码在一个 进程（process）中运行，操作系统则负责管理多个进程。在程序内部，也可以拥有多个同时运行的独立部分。运行这些独立部分的功能被称为 线程（threads）。
将程
                            
                        </div>
                        <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2025-03-02
                        </span>
                            <span class="publish-author">
                                
                                    <i class="fa fa-bookmark fa-fw icon-category"></i>
                                    
                                        <a href="/categories/Rust/" class="post-category">
                                    Rust
                                </a>
                                    
                                
                            </span>
                        </div>
                    </div>
                    
                </div>
            </div>
        
        
            <div class="article col s12 m6" data-aos="fade-up">
                <div class="article-badge right-badge text-color">
                    下一篇&nbsp;<i class="fa fa-chevron-right"></i>
                </div>
                <div class="card">
                    <a href="/2025/02/28/rust-cargoxiang-jie/">
                        <div class="card-image">
                            
                                
                                <img src="/medias/featureimages/21.jpg" class="responsive-img" alt="Rust Cargo 详解">
                            
                            <span class="card-title">Rust Cargo 详解</span>
                        </div>
                    </a>
                    <div class="card-content article-content">
                        <div class="summary block-with-text">
                            
                                1 .Cargo 及其发布配置Cargo 允许使用不同的 发布配置（Release Profiles） 来优化编译和运行。Rust 默认有两个主要的配置：

dev：cargo build，适用于开发，优化较少，编译速度快。
release
                            
                        </div>
                        <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2025-02-28
                            </span>
                            <span class="publish-author">
                                
                                    <i class="fa fa-bookmark fa-fw icon-category"></i>
                                    
                                        <a href="/categories/Rust/" class="post-category">
                                    Rust
                                </a>
                                    
                                
                            </span>
                        </div>
                    </div>
                    
                </div>
            </div>
        
    </div>
</article>
</div>




<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

    <script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

    <script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->


<!-- 代码块折行 -->

    <style type="text/css">
        code[class*="language-"], pre[class*="language-"] {
            white-space: pre !important;
        }
    </style>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

    <div id="floating-toc-btn" class="hide-on-med-and-down">
        <a class="btn-floating btn-large bg-color">
            <i class="fa fa-list"></i>
        </a>
    </div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h2, h3, h4, h5'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4, h5').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换 TOC 目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2022</span>
            <a href="/about" rel="external nofollow noreferrer">xinyichen</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a> 
            <br>
			 <span id="sitetime">载入运行时间...</span>
            
            
            
            
            <br>
            
			
			 
				&nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;<span
						class="white-color">459.1k</span>&nbsp;字
             
            

                
                <script>
                    function siteTime() {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2022";
                        var startMonth = "5";
                        var startDate = "26";
                        var startHour = "21";
                        var startMinute = "10";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);
                        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                            minutes);
                        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                            diffMinutes * minutes) / seconds);
                        if (startYear == todayYear) {
                            document.getElementById("year").innerHTML = todayYear;
                            document.getElementById("sitetime").innerHTML = "本站已运行 " + diffDays + " 天 " + diffHours +
                                " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            document.getElementById("sitetime").innerHTML = "本站已运行 " + diffYears + " 年 " + diffDays +
                                " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                        }
                    }

                    setInterval(siteTime, 1000);
                </script>
            

        </div>
        <!-- <div class="col s12 m4 l4 social-link ">

















</div> -->
    </div>
</footer>

<div class="progress-bar"></div>



<!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<!-- 异步加载 search.js -->
<script src="/js/search.js"></script>

<!-- 延迟加载 search.xml -->
<script type="text/javascript">
    $(function () {
        // 延迟500毫秒加载搜索数据，避免阻塞页面加载
        setTimeout(function () {
            searchFunc("/search.xml", 'searchInput', 'searchResult');
        }, 500);
    });
</script>
<!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


<script src="/libs/materialize/materialize.min.js"></script>
<script src="/libs/masonry/masonry.pkgd.min.js"></script>
<script src="/libs/aos/aos.js"></script>
<script src="/libs/scrollprogress/scrollProgress.min.js"></script>
<script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
<script src="/js/matery.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->


<!-- Baidu Analytics -->


<!-- Baidu Push -->


    <script src="/libs/others/clicklove.js" async="async"></script>




<script type="text/javascript">
    var OriginTitile = document.title,
        st;
    document.addEventListener("visibilitychange", function () {
        document.hidden ? (document.title = "(oﾟvﾟ)ノ Hi", clearTimeout(st)) : (document.title =
            "(*´∇｀*) 欢迎回来！", st = setTimeout(function () {
            document.title = OriginTitile
        }, 3e3))
    })
</script>

<!-- 在线聊天工具  -->



<!-- 背景 canvas-nest -->



    <script src="/libs/instantpage/instantpage.js" type="module"></script>


</body>
</html>