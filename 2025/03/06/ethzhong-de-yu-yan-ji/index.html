<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="ETH中的预言机, 立身于大雪弥漫、浓雾障眼的山口，只能偶尔瞥见未必正确的路径，只需睁大双眼，昂起头颅，走好脚下的路，不管它通向何方。">
    <meta name="description" content="预言机是产生数据馈送的应用程序，使链下数据来源可供区块链用于智能合约。 由于默认情况下，基于以太坊的智能合约无法访问存储在区块链网络外部的信息，预言机是必不可少的。
赋予智能合约使用链下数据执行的能力，扩展了去中心化应用程序的效用和价值。 ">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="white"/>
    <title>ETH中的预言机 | Sparks Fly</title>
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link rel="icon" type="image/x-icon, image/vnd.microsoft.icon" href="/favicon.ico">
    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <style type="text/css">
        
        code[class*="language-"], pre[class*="language-"] {
            white-space: pre !important;
        }

        
    </style>
    <script src="/libs/jquery/jquery.min.js"></script>
<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Sparks Fly" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>

<header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                        <img src="/apple-touch-icon.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Sparks Fly</span>
                </a>
            </div>
            


<!-- <a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul> -->

<!-- 支持二级菜单特性 -->
<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right nav-menu">
    
        <li class="hide-on-med-and-down nav-item">

            
                <a href="/" class="waves-effect waves-light">
                    
                        <i class="fa fa-home"></i>
                    
                    <span>首页</span>
                </a>

            
        </li>
    
        <li class="hide-on-med-and-down nav-item">

            
                <a href="/categories" class="waves-effect waves-light">
                    
                        <i class="fa fa-bookmark"></i>
                    
                    <span>分类</span>
                </a>

            
        </li>
    
        <li class="hide-on-med-and-down nav-item">

            
                <a href="/archives" class="waves-effect waves-light">
                    
                        <i class="fa fa-archive"></i>
                    
                    <span>归档</span>
                </a>

            
        </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
            <img src="/medias/avatars/avatar.png"
                 class="logo-img circle responsive-img">
        
        <div class="logo-name">Sparks Fly</div>
        <div class="logo-desc">
            
                Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
            <li class="m-nav-item">
                
                    <a href="/" class="waves-effect waves-light">
                        
                            <i class="fa fa-fw fa-home"></i>
                        
                        首页
                    </a>
                
            </li>
        
            <li class="m-nav-item">
                
                    <a href="/categories" class="waves-effect waves-light">
                        
                            <i class="fa fa-fw fa-bookmark"></i>
                        
                        分类
                    </a>
                
            </li>
        
            <li class="m-nav-item">
                
                    <a href="/archives" class="waves-effect waves-light">
                        
                            <i class="fa fa-fw fa-archive"></i>
                        
                        归档
                    </a>
                
            </li>
        
        
    </ul>
</div>

        </div>

        
    </nav>

</header>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/6.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">ETH中的预言机</h1>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
        <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">Awsome</span>
                        </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                        <div class="post-cate">
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                                <a href="/categories/WEB3/" class="post-category">
                                    WEB3
                                </a>
                            
                        </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                    <div class="post-date info-break-policy">
                        <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                        2025-03-06
                    </div>
                

                
                    <div class="post-date info-break-policy">
                        <i class="fa fa-calendar-check-o fa-fw"></i>更新日期:&nbsp;&nbsp;
                        2025-03-06
                    </div>
                

                
                    <div class="info-break-policy">
                        <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                        7.9k
                    </div>
                

                
                    <div class="info-break-policy">
                        <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                        28 分
                    </div>
                

                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>预言机是产生数据馈送的应用程序，使链下数据来源可供区块链用于智能合约。 由于默认情况下，基于以太坊的智能合约无法访问存储在区块链网络外部的信息，预言机是必不可少的。</p>
<p>赋予智能合约使用链下数据执行的能力，扩展了去中心化应用程序的效用和价值。 例如，链上预测市场依靠预言机提供有关结果的信息，用于验证用户的预测。 假设 Alice 下注 20 个以太币赌谁将成为下一任美国 总统。 在这种情况下，预测市场去中心化应用程序需要预言机来确认选举结果，并判定 Alice 是否有资格获得付款。</p>
<h2 id="什么是区块链预言机？"><a href="#什么是区块链预言机？" class="headerlink" title="什么是区块链预言机？"></a>什么是区块链预言机？</h2><p>预言机是指获取、验证外部信息（即存储在链下的信息）并将外部信息传送给在区块链上运行的智能合约的应用程序。 预言机除了“拉取”链下数据并在以太坊上广播以外，还可以将信息从区块链“推送”到外部系统，例如，一旦用户通过以太坊交易发送费用，就解锁智能锁。</p>
<p>如果没有预言机，智能合约将只能使用链上数据。</p>
<p>预言机的差别在于数据来源（一种或多种来源）、信任模型（中心化或去中心化）和系统架构（立即读取、发布-订阅和请求-响应）。 我们还可以根据以下因素区分预言机：是否检索外部数据供链上合约使用（输入预言机）、将区块链中的信息发送给链下应用程序（输出预言机）或在链下执行计算任务（计算预言机）。</p>
<h2 id="智能合约为什么需要预言机？"><a href="#智能合约为什么需要预言机？" class="headerlink" title="智能合约为什么需要预言机？"></a>智能合约为什么需要预言机？</h2><p>许多开发者将智能合约视为在区块链上特定地址运行的代码。 然而，对<a href="https://ethereum.org/zh/smart-contracts/">智能合约更为普遍的观点</a>是，它们是自动执行的软件程序，一旦满足特定条件，就能够执行各方之间的协议 - 因此术语称为“智能合约”。</p>
<p>但是，使用智能合约执行人之间的协议并非易事，因为以太坊是确定性系统。 <a href="https://en.wikipedia.org/wiki/Deterministic_algorithm">确定性系统(opens in a new tab)</a>是指在给定初始状态和特定输入的情况下始终产生相同结果的系统，这意味着根据输入计算输出的过程不存在随机性或变化。</p>
<p>要实现确定性执行，区块链将节点限制为通过<em>仅</em>使用存储在区块链本身中的数据就简单的二进制 (true/false) 问题达成共识。 这类问题的示例包括：</p>
<ul>
<li>“帐户所有者（由公钥识别）是否使用配对私钥签署该交易?”</li>
<li>“该帐户是否有足够资金支付这笔交易？”</li>
<li>“这笔交易在该智能合约中是否有效？”等等。</li>
</ul>
<p>如果区块链从外部来源（例如现实世界）接收信息，确定性将不可能实现，阻止节点就区块链状态变化的有效性达成一致。 以一个智能合约为例，该合约根据从一个传统价格应用程序接口获得的当前以太币-美元汇率执行交易。 该汇率可能会经常变动（更不用说该应用程序接口可能被弃用或遭到黑客攻击），这意味着执行相同合约代码的节点会得出不同的结果。</p>
<p>对于像以太坊这样在世界各地有数千个节点处理交易的公共区块链，确定性至关重要。 由于没有集中管理机构作为真实性来源，节点需要在进行相同交易后达到相同状态的机制。 节点 A 执行智能合约的代码并得到结果“3”，而节点 B 在运行相同交易后得到“7”，这将打破共识并消除以太坊作为去中心化计算平台的价值。</p>
<p>这种情况还突显了设计区块链从外部来源获取信息的问题。 然而，预言机解决了这一问题，它从链下来源获取信息并存储在区块链上供智能合约使用。 由于存储在链上的信息是不可更改和公开可用的，以太坊节点可以安全地使用预言机导入的链下数据计算状态变化，且不会打破共识。</p>
<p>为此，预言机通常由链上运行的智能合约和一些链下组件构成。 链上合约接收其他智能合约的数据请求，并将这些请求传送给链下组件（称为预言机节点）。 这类预言机节点可以查询数据源—例如使用应用程序接口 (API)—并发送交易将请求的数据存储在智能合约的存储中。</p>
<p>就本质而言，区块链预言机弥合了区块链和外部环境之间的信息缺口，创建了“混合智能合约”。 混合智能合约的工作原理基于链上合约代码和链下基础设施的结合。 去中心化预测市场就是混合智能合约的一个很好的示例。 其他示例可能包括作物保险智能合约，在一组预言机确定某些天气现象已经发生时这些合约做出赔付。</p>
<h2 id="什么是预言机问题？"><a href="#什么是预言机问题？" class="headerlink" title="什么是预言机问题？"></a>什么是预言机问题？</h2><p>预言机解决了一个重要问题，但也带来了一些复杂性，例如：</p>
<ul>
<li>如何验证注入信息是从正确来源提取的或者未被篡改？</li>
<li>如何确保这些数据始终可用并且定期更新？</li>
</ul>
<p>所谓的“预言机问题”显示了使用区块链预言机给智能合约发送输入时出现的问题。 来自预言机的数据必须正确，智能合约才能正确执行。 而且，必须“信赖”预言机运营商提供准确信息，会削弱智能合约的“无需信任性”。</p>
<p>不同的预言机对于预言机问题有着不同的解决方案，稍后将进行探讨。 通常会根据预言机应对以下挑战的能力来评估它们：</p>
<ol>
<li><strong>正确性</strong>：预言机不应导致智能合约基于无效的链下数据触发状态变化。 预言机必须保证数据的<em>真实性</em>与<em>完整性</em>。 真实性是指数据是从正确来源获取的，完整性是指数据在发送到链上前保持完好无缺（即数据未修改过）。</li>
<li><strong>可用性</strong>：预言机不应延迟或阻止智能合约执行操作或触发状态变化。 这意味着预言机提供的数据必须<em>在请求时可用</em>并且不会出现间断。</li>
<li><strong>激励兼容性</strong>：预言机应激励链下数据提供者向智能合约提交正确的信息。 奖励兼容性包括<em>可归因性</em>和<em>问责性</em>。 可归因性指将一条外部信息与其提供者联系起来，而问责性则将数据提供者和他们提供的信息联结起来，因此能够根据提供的数据质量奖励或者惩罚数据提供者。</li>
</ol>
<h2 id="区块链预言机服务是如何运作的？"><a href="#区块链预言机服务是如何运作的？" class="headerlink" title="区块链预言机服务是如何运作的？"></a>区块链预言机服务是如何运作的？</h2><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><p>用户是指需要区块链外部的信息以完成特定操作的实体（即智能合约）。 预言机服务的基本工作流程始于用户向预言机合约发送数据请求。 数据请求通常将回答下列一部分或所有问题：</p>
<ol>
<li>链下节点可以在哪些来源中查询请求的信息？</li>
<li>报告者如何处理数据来源中的信息并提取有用的数据点？</li>
<li>有多少预言机节点可以参与数据检索？</li>
<li>应如何管理预言机报告中的差异？</li>
<li>在筛选提交并将报告聚合为单个值时应该采用什么方法?</li>
</ol>
<h3 id="预言机合约"><a href="#预言机合约" class="headerlink" title="预言机合约"></a>预言机合约</h3><p>预言机合约是预言机服务的链上部分。 它侦听其他合约的数据请求，将数据查询转送到预言机节点，并将返回的数据广播到客户端合约。 该合约还可以对返回的数据点进行一些计算，以产生聚合值并发送给请求合约。</p>
<p>预言机合约公开了一些函数，客户端合约在发出数据请求时调用它们。 收到新查询后，智能合约将触发一个<a href="https://ethereum.org/zh/developers/docs/smart-contracts/anatomy/#events-and-logs">日志事件</a>，其中有数据请求详细信息。 这将通知订阅该日志的链下节点（通常使用类似 JSON-RPC <code>eth_comment</code> 的命令），让其继续检索日志事件中定义的数据。</p>
<p>下面是 Pedro Costa 提供的<a href="https://medium.com/@pedrodc/implementing-a-blockchain-oracle-on-ethereum-cedc7e26b49e">预言机合约示例(opens in a new tab)</a>。 它是一个简单的预言机服务，可以在其他智能合约发出请求时查询链下应用程序接口，并在区块链上存储请求的信息：</p>
<pre class="line-numbers language-solidity"><code class="language-solidity">pragma solidity >=0.4.21 <0.6.0;

contract Oracle {
  Request[] requests; //list of requests made to the contract
  uint currentId = 0; //increasing request id
  uint minQuorum = 2; //minimum number of responses to receive before declaring final result
  uint totalOracleCount = 3; // Hardcoded oracle count

  // defines a general api request
  struct Request {
    uint id;                            //request id
    string urlToQuery;                  //API url
    string attributeToFetch;            //json attribute (key) to retrieve in the response
    string agreedValue;                 //value from key
    mapping(uint => string) answers;     //answers provided by the oracles
    mapping(address => uint) quorum;    //oracles which will query the answer (1=oracle hasn't voted, 2=oracle has voted)
  }

  //event that triggers oracle outside of the blockchain
  event NewRequest (
    uint id,
    string urlToQuery,
    string attributeToFetch
  );

  //triggered when there's a consensus on the final result
  event UpdatedRequest (
    uint id,
    string urlToQuery,
    string attributeToFetch,
    string agreedValue
  );

  function createRequest (
    string memory _urlToQuery,
    string memory _attributeToFetch
  )
  public
  {
    uint length = requests.push(Request(currentId, _urlToQuery, _attributeToFetch, ""));
    Request storage r = requests[length-1];

    // Hardcoded oracles address
    r.quorum[address(0x6c2339b46F41a06f09CA0051ddAD54D1e582bA77)] = 1;
    r.quorum[address(0xb5346CF224c02186606e5f89EACC21eC25398077)] = 1;
    r.quorum[address(0xa2997F1CA363D11a0a35bB1Ac0Ff7849bc13e914)] = 1;

    // launch an event to be detected by oracle outside of blockchain
    emit NewRequest (
      currentId,
      _urlToQuery,
      _attributeToFetch
    );

    // increase request id
    currentId++;
  }

  //called by the oracle to record its answer
  function updateRequest (
    uint _id,
    string memory _valueRetrieved
  ) public {

    Request storage currRequest = requests[_id];

    //check if oracle is in the list of trusted oracles
    //and if the oracle hasn't voted yet
    if(currRequest.quorum[address(msg.sender)] == 1){

      //marking that this address has voted
      currRequest.quorum[msg.sender] = 2;

      //iterate through "array" of answers until a position if free and save the retrieved value
      uint tmpI = 0;
      bool found = false;
      while(!found) {
        //find first empty slot
        if(bytes(currRequest.answers[tmpI]).length == 0){
          found = true;
          currRequest.answers[tmpI] = _valueRetrieved;
        }
        tmpI++;
      }

      uint currentQuorum = 0;

      //iterate through oracle list and check if enough oracles(minimum quorum)
      //have voted the same answer as the current one
      for(uint i = 0; i < totalOracleCount; i++){
        bytes memory a = bytes(currRequest.answers[i]);
        bytes memory b = bytes(_valueRetrieved);

        if(keccak256(a) == keccak256(b)){
          currentQuorum++;
          if(currentQuorum >= minQuorum){
            currRequest.agreedValue = _valueRetrieved;
            emit UpdatedRequest (
              currRequest.id,
              currRequest.urlToQuery,
              currRequest.attributeToFetch,
              currRequest.agreedValue
            );
          }
        }
      }
    }
  }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="预言机节点"><a href="#预言机节点" class="headerlink" title="预言机节点"></a>预言机节点</h3><p>预言机节点是预言机服务的链下部分。 它从外部来源提取信息，例如托管在第三方服务器上的应用程序接口，并将信息放在链上供智能合约使用。 预言机节点侦听来自链上预言机合约的事件，继而完成日志中描述的任务。</p>
<p>预言机节点的常见任务是，向应用程序接口服务发送 <a href="https://www.w3schools.com/tags/ref_httpmethods.asp">HTTP GET(opens in a new tab)</a> 请求，解析响应以提取相关数据，设置为区块链可读的输出格式，并通过将输入包含在预言机合约的交易中将其发送到链上 在利用“真实性证明”证明所提交信息的有效性和完整性时，可能也会用到预言机节点，我们稍后会对此进行探讨。</p>
<p>计算预言机也依赖链下节点执行计算任务，但因为燃料成本和区块大小限制，这类计算在链上执行是不切实际的。 例如，预言机节点的任务可能是生成一个可验证的随机数字（例如，用于区块链游戏）。</p>
<h2 id="预言机设计模式"><a href="#预言机设计模式" class="headerlink" title="预言机设计模式"></a>预言机设计模式</h2><p>预言机有不同的类型，包括<em>立即读取</em>、<em>发布-订阅</em>和<em>请求-响应</em>，后两者在太坊智能合约中最受欢迎。 在此我们简单描述发布-订阅和请求-响应模型。</p>
<h3 id="发布-订阅预言机"><a href="#发布-订阅预言机" class="headerlink" title="发布-订阅预言机"></a>发布-订阅预言机</h3><p>这类预言机公开了“数据馈送”，其他合约通常可以通过读取数据馈来获取信息。 在这种情况下，数据可能会频繁变化，因此客户端合约必须侦听预言机存储中数据的更新。 例如，向用户提供最新以太币-美元价格信息的预言机。</p>
<h3 id="请求-响应预言机"><a href="#请求-响应预言机" class="headerlink" title="请求-响应预言机"></a>请求-响应预言机</h3><p>请求-响应设置允许客户端合约请求除发布-订阅预言机所提供数据以外的任意数据。 当数据集太大而无法存储在智能合约的存储中，并且/或者用户在任何时间点只需要一小部分数据时，请求-响应预言机是理想之选。</p>
<p>虽然比发布-订阅预言机复杂，但请求-响应预言机基本上和我们在上一节中描述的一样。 预言机将有一个链上组件，用于接收数据请求并传送给链下节点进行处理。</p>
<p>发起数据查询的用户必须承担从链下来源检索信息的费用。 客户端合约还必须提供资金，用以支付预言机合约通过请求中指定的回调函数返回响应所产生的燃料费用。</p>
<h2 id="中心化和去中心化预言机"><a href="#中心化和去中心化预言机" class="headerlink" title="中心化和去中心化预言机"></a>中心化和去中心化预言机</h2><h3 id="中心化预言机"><a href="#中心化预言机" class="headerlink" title="中心化预言机"></a>中心化预言机</h3><p>中心化预言机由单个实体控制，该实体负责聚合链下信息并按照请求更新预言机合约的数据。 中心化预言机效率高，因为它们依赖单一真实性来源。 在专有数据集由所有者直接发布并有公认签名的情况下，中心化预言机表现更佳。 然而，它们也带来了弊端：</p>
<h4 id="低正确性保障"><a href="#低正确性保障" class="headerlink" title="低正确性保障"></a>低正确性保障</h4><p>使用中心化预言机时，无法确认提供的信息是否正确。 甚至“信誉良好”的提供者会耍无赖或者遭遇黑客攻击。 如果预言机被破坏，智能合约将基于错误数据执行。</p>
<h4 id="可用性差"><a href="#可用性差" class="headerlink" title="可用性差"></a>可用性差</h4><p>中心化预言机无法保证始终向其他智能合约提供链下数据。 如果提供者决定关闭服务或者黑客劫持了预言机的链下组件，智能合约则会面临拒绝服务 (Dos) 攻击的风险。</p>
<h4 id="激励兼容性差"><a href="#激励兼容性差" class="headerlink" title="激励兼容性差"></a>激励兼容性差</h4><p>中心化预言机的激励往往设计不善或根本没有激励，鼓励数据提供者发送准确/未更改的信息。 付钱给预言机以保证正确性并不能确保诚信。 随着智能合约控制的价值体量增加，这个问题愈加严重。</p>
<h3 id="去中心化预言机"><a href="#去中心化预言机" class="headerlink" title="去中心化预言机"></a>去中心化预言机</h3><p>去中心化预言机旨在通过消除单点故障来打破中心化预言机的局限性。 去中心化预言机服务由对等网络中的多个参与者组成，这些参与者就链下数据达成共识，然后再将数据发送到智能合约。</p>
<p>理想情况下，去中心化预言机应该是无需许可、去信任且不受中心机构管理；在现实中，预言机存在着不同程度的去中心化。 有半去中心化的预言机网络，任何人都可以参与其中，但由“所有者“根据以往表现批准和移除节点。 也存在着完全去中心化的预言机网络：这些网络通常作为独立区块链运行，并且已经确定了协调节点和惩罚不良行为的共识机制。</p>
<p>使用去中心化预言机有以下好处：</p>
<h3 id="高正确性保障"><a href="#高正确性保障" class="headerlink" title="高正确性保障"></a>高正确性保障</h3><p>去中心化预言机尝试使用不同的方法实现数据的正确性。 其中包括使用证明来证明返回信息的真实性和完整性，以及要求多个实体就链下数据的有效性集体达成一致。</p>
<h4 id="真实性证明"><a href="#真实性证明" class="headerlink" title="真实性证明"></a>真实性证明</h4><p>真实性证明是一种加密机制，支持对从外部来源检索的信息进行独立验证。 这些证明可以验证信息的来源，并在检索后发现对数据可能进行的更改。</p>
<p>真实性证明的示例包括：</p>
<p><strong>传输层安全性 (TLS) 证明</strong>：预言机节点通常使用基于传输层安全性 (TLS) 协议的安全 HTTP 连接从外部数据源检索数据。 一些去中心化预言机使用真实性证明验证传输层安全性会话（即，确认节点和特定服务器之间的信息交换），并确认会话内容未被改动。</p>
<p><strong>可信执行环境 (TEE) 认证</strong>：<a href="https://en.wikipedia.org/wiki/Trusted_execution_environment">可信执行环境(opens in a new tab)</a> (TEE) 是一种沙盒计算环境，它与主机系统的操作进程隔离。 可信执行环境确保在计算环境中存储/使用的任何应用代码或数据都保持完整性、保密性和不可变性。 用户还可以生成一个认证，证明应用程序实例正在可信执行环境中运行。</p>
<p>某些类别的去中心化预言机要求预言机节点运营者提供可信执行环境认证。 这向用户证实，节点运营者在可信执行环境中运行预言机客户端的实例。 可信执行环境防止外部进程更改或读取应用程序的代码和数据，因此，这些认证证明预言机节点保持了信息的完整性和保密性。</p>
<h4 id="基于共识的信息验证"><a href="#基于共识的信息验证" class="headerlink" title="基于共识的信息验证"></a>基于共识的信息验证</h4><p>为智能合约提供数据时，中心化预言机依靠单一真实性来源，因此有可能发布不准确的信息。 去中心化预言机依靠多个预言机节点查询链下信息，解决了这个问题。 通过对多个来源的数据进行比较，去中心化预言机降低了将无效信息传递到链上合约的风险。</p>
<p>然而，去中心化预言机必须处理从多个链下来源检索的信息中的差异。 为了尽量减少信息差异并确保传送给预言机合约的数据反映了预言机节点的集体看法，去中心化预言机采用了下列机制：</p>
<h5 id="对数据的准确性进行投票-质押"><a href="#对数据的准确性进行投票-质押" class="headerlink" title="对数据的准确性进行投票/质押"></a>对数据的准确性进行投票/质押</h5><p>一些去中心化预言机网络要求参与者对数据查询答案的准确性进行投票或质押（例如，“谁赢得了 2020 年美国大选?”） （例如，“谁赢得了 2020 年美国大选?”） 然后，聚合协议聚合投票和质押，并将多数参与者支持的答案作为有效答案。</p>
<p>如果节点的答案不同于多数答案，将对其进行惩罚，即将其代币分发给提供更正确值的其他节点。 强制节点在提供数据之前提供保证金将激励节点做出诚实的响应，因为假定节点是理性的经济活动参与者，意在最大限度地增加回报。</p>
<p>质押/投票还能保护去中心化预言机免受女巫攻击，在这种攻击中，恶意参与者创建多个身份来利用共识系统。 然而，质押机制不能防止“揩油行为”（预言机节点从其他节点复制信息）和“懒散验证”（预言机节点随大流而不亲自验证信息）。</p>
<h5 id="谢林点机制"><a href="#谢林点机制" class="headerlink" title="谢林点机制"></a>谢林点机制</h5><p><a href="https://en.wikipedia.org/wiki/Focal_point_(game_theory)">谢林点(opens in a new tab)</a>是一个博弈论概念，它假设在缺乏任何沟通的情况下，多个实体总是默认对一个问题选择共同解决方案。 谢林点机制常用于去中心化预言机网络，使节点对数据请求的应答达成共识。</p>
<p>这方面的一个早期想法是<a href="https://blog.ethereum.org/2014/03/28/schellingcoin-a-minimal-trust-universal-data-feed/">谢林币(opens in a new tab)</a>，这是一种提议的数据馈送，参与者提交“标量”问题的答案（这些问题的答案由数量描述，例如“以太币的价格是多少?”）及存款。 提供的值在第 25 和第 75 <a href="https://en.wikipedia.org/wiki/Percentile">百分位(opens in a new tab)</a>之间的用户将得到奖励，而提供的值大幅偏离中值的用户将受到惩罚。</p>
<p>虽然谢林币目前已不存在，但许多去中心化预言机—特别是 <a href="https://docs.makerdao.com/smart-contract-modules/oracle-module">Maker 协议预言机(opens in a new tab)</a>—仍使用谢林点机制来提高预言机数据的准确性。 每个 Maker 预言机均由提交抵押品资产的市场价格的链下对等节点网络（“中继者”和“馈送者”）和链上“中值器”合约组成，后者计算所有提供价值的中值。 规定的延迟期结束后，该中值成为相关资产的新参考价格。</p>
<p>使用谢林点机制的其他预言机示例包括 <a href="https://docs.chain.link/docs/off-chain-reporting/">Chainlink 链下报告(opens in a new tab)</a>和 <a href="https://witnet.io/">Witnet(opens in a new tab)</a>。 在这两种系统中，对等网络中的预言机节点的答复聚合成一个单一聚合值，如平均值或中值。 根据其答复与聚合值的一致或偏离程度奖励或惩罚节点。</p>
<p>谢林点机制具有吸引力，因为这类机制能够最大限度地减少对链上的影响（只需要发送一笔交易）同时又能保证去中心化。 后者是可行的，因为节点必须批准已提交答复的列表，然后再将答复输入生成平均值/中值的算法。</p>
<h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><p>去中心化预言机服务确保链下数据对智能合约的高可用性。 高可用性是通过对链下信息来源和负责将信息传输到链上的节点同时去中心化实现的。</p>
<p>这确保了容错，因为预言机合约能够依靠多个节点（这些节点也依靠多个数据源）执行其他合约发出的查询。 在信息来源<em>和</em>节点运营商层面实现去中心化至关重要—提供从同一来源检索的信息的预言机节点网络将遇到与中心化预言机相同的问题。</p>
<p>基于质押的预言机也可以对未能快速响应数据请求的节点运营商进行惩罚。 这极大地激励了预言机节点投资于容错基础设施并及时提供数据。</p>
<h3 id="激励兼容性好"><a href="#激励兼容性好" class="headerlink" title="激励兼容性好"></a>激励兼容性好</h3><p>去中心化预言机采纳了不同的激励设计，避免预言机节点中出现<a href="https://en.wikipedia.org/wiki/Byzantine_fault">拜占庭(opens in a new tab)</a>行为。 具体而言，它们实现了<em>可归因性</em>和<em>问责性</em>：</p>
<ol>
<li>通常，要求去中心化预言机节点对它们为了响应数据请求而提供的数据签名。 这些信息有助于评估预言机节点的历史表现，让用户在发出数据请求时筛选掉不可靠的预言机节点。 例如 Witnet 的<a href="https://docs.witnet.io/intro/about/architecture#algorithmic-reputation-system">算法信誉系统(opens in a new tab)</a>。</li>
<li>如前所述，去中心化预言机可能要求节点对其提交数据的真实性的可信度进行质押。 如果声明得到证实，这笔质押可以连同诚信服务的奖励一起返还。 但是如果信息不正确，也可以对节点进行惩罚，这就提供了一定程度的问责性。</li>
</ol>
<h2 id="预言机在智能合约中的应用"><a href="#预言机在智能合约中的应用" class="headerlink" title="预言机在智能合约中的应用"></a>预言机在智能合约中的应用</h2><p>以下是以太坊中预言机的常见用例：</p>
<h3 id="检索金融数据"><a href="#检索金融数据" class="headerlink" title="检索金融数据"></a>检索金融数据</h3><p><a href="https://ethereum.org/zh/defi/">去中心化金融</a> (DeFi) 应用程序允许点对点贷款、借款和资产交易。 通常，这需要获取不同的金融信息，包括汇率数据（用于计算加密货币的法币价值或比较代币的价格）和资本市场数据（用于计算代币化资产的价值，如黄金或美元）。</p>
<p>例如，一个去中心化金融贷款协议需要查询作为抵押品存储的资产（例如以太币）的当前市场价格。 这样，合约可以确定抵押品资产的价值，并确定它能从系统中借出多少钱。</p>
<p>去中心化金融中热门的“价格预言机”（常用名称）包括 Chainlink Price Feeds、Compound Protocol 的<a href="https://compound.finance/docs/prices">开放式喂价工具(opens in a new tab)</a>、Uniswap 的<a href="https://docs.uniswap.org/contracts/v2/concepts/core-concepts/oracles">时间加权平均价格 (TWAP) (opens in a new tab)</a>以及 <a href="https://docs.makerdao.com/smart-contract-modules/oracle-module">Maker 预言机(opens in a new tab)</a>。</p>
<p>在将这些价格预言机整合到项目中之前，构建者应该了解它们附带的注意事项。 本<a href="https://blog.openzeppelin.com/secure-smart-contract-guidelines-the-dangers-of-price-oracles/">文(opens in a new tab)</a>详细分析了计划使用任何上述价格预言机时要考虑的因素。</p>
<p>下面是一个示例，说明如何使用 Chainlink 喂价工具从智能合约中检索最新以太币价格：</p>
<pre class="line-numbers language-solidity"><code class="language-solidity">pragma solidity ^0.6.7;

import "@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol";

contract PriceConsumerV3 {

    AggregatorV3Interface internal priceFeed;

    /**
     * Network: Kovan
     * Aggregator: ETH/USD
     * Address: 0x9326BFA02ADD2366b30bacB125260Af641031331
     */
    constructor() public {
        priceFeed = AggregatorV3Interface(0x9326BFA02ADD2366b30bacB125260Af641031331);
    }

    /**
     * Returns the latest price
     */
    function getLatestPrice() public view returns (int) {
        (
            uint80 roundID,
            int price,
            uint startedAt,
            uint timeStamp,
            uint80 answeredInRound
        ) = priceFeed.latestRoundData();
        return price;
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="生成可验证的随机性"><a href="#生成可验证的随机性" class="headerlink" title="生成可验证的随机性"></a>生成可验证的随机性</h3><p>某些区块链应用程序（如基于区块链的游戏或彩票方案），需要高度的不可预测性和随机性才能有效工作。 然而，区块链的确定性执行消除了任何随机性。</p>
<p>原始方法是采用伪随机加密函数（例如 <code>blockhash</code>），但是它们可被[矿工操纵(opens in a new tab)](<a href="https://ethereum.stackexchange.com/questions/3140/risk-of-using-blockhash-other-miners-preventing-attack#:~:text=So">https://ethereum.stackexchange.com/questions/3140/risk-of-using-blockhash-other-miners-preventing-attack#:~:text=So</a> while the miners can,to one of the players.)，对工作量证明算法进行求解。 同样，以太坊<a href="https://ethereum.org/zh/roadmap/merge/">切换到权益证明</a>意味着开发者不再能够依赖 <code>blockhash</code> 得到链上随机性。 信标链的 <a href="https://eth2book.info/altair/part2/building_blocks/randomness">RANDAO 机制(opens in a new tab)</a>为随机性来源提供了替代选择。</p>
<p>可以在链下生成随机值并发送到链上，但这样做对用户有很高的信任要求。 他们必须相信值确实是通过不可预测的机制产生的，并且未在传输过程中遭到改动。</p>
<p>为链下计算设计的预言机解决了这一问题，它们安全地生成链下随机结果并连同证实该过程不可预测性的加密证明一起在链上广播。 <a href="https://docs.chain.link/docs/chainlink-vrf/">Chainlink VRF(opens in a new tab)</a>（可验证随机函数）便是一个示例，它是一个可证明公平且防篡改的随机数生成器 (RNG)，用于为依靠不可预测结果的应用程序构建可靠的智能合约。 另一个示例是 <a href="https://docs.api3.org/explore/qrng/">API3 QRNG(opens in a new tab)</a>，它提供量子随机数生成器 (QRNG)，是基于量子现象的 Web3 量子随机数生成的公共方法，由澳大利亚国立大学 (ANU) 提供。</p>
<h3 id="获取事件结果"><a href="#获取事件结果" class="headerlink" title="获取事件结果"></a>获取事件结果</h3><p>有了预言机，创建响应真实事件的智能合约并非难事。 预言机服务允许合约通过链下组件连接到外部应用程序接口并使用来自这些数据源的信息，实现了这一点。 例如，前面介绍的预测去中心化应用程序可能会请求预言机返回可信链下来源（如美联社）提供的选举结果。</p>
<p>使用预言机检索基于真实结果的数据，可以实现其他新颖的用例；例如，去中心化保险产品需要关于天气、灾害等的准确信息才能有效地工作。</p>
<h3 id="智能合约自动化"><a href="#智能合约自动化" class="headerlink" title="智能合约自动化"></a>智能合约自动化</h3><p>智能合约不会自动运行；相反，外部帐户 (EOA) 或另一个合约帐户必须触发正确的函数来执行合约代码。 大多数情况下，合约的大部分函数是公共函数，可由外部帐户和其他合约调用。</p>
<p>但合约中也有其他合约无法访问的<em>私有函数</em>，然而它们对于去中心化应用程序的整体功能至关重要。 示例包括定期为用户铸造新非同质化代币的 <code>mintERC721Token()</code> 函数、在预测市场中付款的函数或在去中心化交易所中解锁质押代币的函数。</p>
<p>开发者需要每隔一段时间触发这些函数，以保持应用程序平稳运行。 然而，这可能导致开发者在普通任务上浪费更多时间，它是智能合约自动执行吸引人的原因。</p>
<p>一些去中心化预言机网络提供自动化服务，允许链下预言机节点根据用户定义的参数触发智能合约函数。 通常，这需要向预言机服务“注册”目标合约，提供资金支付预言机运营商，并指定触发合约的条件或时间。</p>
<p>Chainlink 的 <a href="https://chain.link/keepers">Keeper 网络(opens in a new tab)</a>提供智能合约方案，以信任最小化和去中心化的方式将常规维护工作外包。 阅读官方 <a href="https://docs.chain.link/docs/chainlink-keepers/introduction/">Keeper 文档(opens in a new tab)</a>，了解有关如何使合约与 Keeper 兼容以及如何使用 Upkeep 服务的信息。</p>
<h2 id="如何使用区块链预言机"><a href="#如何使用区块链预言机" class="headerlink" title="如何使用区块链预言机"></a>如何使用区块链预言机</h2><p>许多预言机应用程序都可以集成到以太坊去中心化应用程序中，如下所示：</p>
<p><strong><a href="https://chain.link/">Chainlink(opens in a new tab)</a></strong> - <em>Chainlink 去中心化预言机网络提供防篡改的输入、输出和计算，支持任何区块链上的高级智能合约。</em></p>
<p><strong><a href="https://chroniclelabs.org/">Chronicle(opens in a new tab)</a></strong> - <em>Chronicle 通过开发真正可扩展、经济高效、去中心化且可验证的预言机来克服当前链上数据传输面临的局限。</em></p>
<p><strong><a href="https://witnet.io/">Witnet(opens in a new tab)</a></strong> - <em>Witnet 是一种无需许可、去中心化和抗审查的预言机，帮助智能合约对真实事件做出响应，提供强大的加密经济保障。</em></p>
<p><strong><a href="https://uma.xyz/">UMA 预言机(opens in a new tab)</a></strong> - <em>UMA 的乐观预言机允许智能合约快速接收不同应用程序的任何类型的数据，包括保险、金融衍生品和预测市场。</em></p>
<p><strong><a href="https://tellor.io/">Tellor(opens in a new tab)</a></strong> - <em>Tellor 是一种透明的、无需许可的预言机协议，可以让智能合约在需要时轻松获取任何数据。</em></p>
<p><strong><a href="https://bandprotocol.com/">Band Protocol(opens in a new tab)</a></strong> - <em>Band Protocol 是一个跨链数据预言机平台，它将真实数据和应用程序接口聚合并连接到智能合约。</em></p>
<p><strong><a href="https://paralink.network/">Paralink(opens in a new tab)</a></strong> - <em>Paralink 为运行在以太坊和其他热门区块链上的智能合约提供一个开源的去中心化预言机平台。</em></p>
<p><strong><a href="https://pyth.network/">Pyth 网络(opens in a new tab)</a></strong> - <em>Pyth 网络是第一方金融预言机网络，旨在在防篡改、去中心化和自我可持续的环境中在链上发布连续的真实数据。</em></p>
<p><strong><a href="https://www.api3.org/">API3 去中心化自治组织(opens in a new tab)</a></strong> - <em>API3 去中心化自治组织提供第一方预言机解决方案，在智能合约的去中心化解决方案中实现更高的来源透明度、安全性和可扩展性</em>。</p>
<p><strong><a href="https://supra.com/">Supra(opens in a new tab)</a></strong> - 跨链解决方案的垂直集成工具包，可互连所有区块链，不论公共区块链（一层网络和二层网络）还是私人区块链（企业），提供可用于链上和链下用例的去中心化预言机价格源。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                           
                        </div>
                    
                </div>
                <div class="post_share"
                     style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
            <div class="article col s12 m6" data-aos="fade-up">
                <div class="article-badge left-badge text-color">
                    <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
                <div class="card">
                    <a href="/2025/03/06/ethzhong-de-kuo-rong-fang-an/">
                        <div class="card-image">
                            
                                
                                <img src="/medias/featureimages/3.jpg" class="responsive-img" alt="ETH中的扩容简介">
                            
                            <span class="card-title">ETH中的扩容简介</span>
                        </div>
                    </a>
                    <div class="card-content article-content">
                        <div class="summary block-with-text">
                            
                                扩容概述随着以太坊使用人数增加，区块链已经达到了一定的容量限制。 这提高了网络使用成本，从而导致需要“扩容解决方案”。 目前正在研究、测试和执行多种解决方案，这些方案采取不同的办法来实现类似的目标。
可扩展性的主要目标是，在不牺牲去中心化或
                            
                        </div>
                        <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2025-03-06
                        </span>
                            <span class="publish-author">
                                
                                    <i class="fa fa-bookmark fa-fw icon-category"></i>
                                    
                                        <a href="/categories/WEB3/" class="post-category">
                                    WEB3
                                </a>
                                    
                                
                            </span>
                        </div>
                    </div>
                    
                </div>
            </div>
        
        
            <div class="article col s12 m6" data-aos="fade-up">
                <div class="article-badge right-badge text-color">
                    下一篇&nbsp;<i class="fa fa-chevron-right"></i>
                </div>
                <div class="card">
                    <a href="/2025/03/06/ethzhong-de-zui-da-ke-ti-qu-jie-zhi-mev/">
                        <div class="card-image">
                            
                                
                                <img src="/medias/featureimages/6.jpg" class="responsive-img" alt="ETH中的最大可提取价值 (MEV)">
                            
                            <span class="card-title">ETH中的最大可提取价值 (MEV)</span>
                        </div>
                    </a>
                    <div class="card-content article-content">
                        <div class="summary block-with-text">
                            
                                最大可提取价值 (MEV) 是指通过在区块中添加和排除交易并更改区块中的交易顺序，可以从区块生产中提取的超过标准区块奖励和燃料费用的最大值。
最大可提取价值最大可提取价值首先应用于工作量证明背景下，最初称为“矿工可提取价值”。 这是因为在工
                            
                        </div>
                        <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2025-03-06
                            </span>
                            <span class="publish-author">
                                
                                    <i class="fa fa-bookmark fa-fw icon-category"></i>
                                    
                                        <a href="/categories/WEB3/" class="post-category">
                                    WEB3
                                </a>
                                    
                                
                            </span>
                        </div>
                    </div>
                    
                </div>
            </div>
        
    </div>
</article>
</div>




<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

    <script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

    <script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->


<!-- 代码块折行 -->

    <style type="text/css">
        code[class*="language-"], pre[class*="language-"] {
            white-space: pre !important;
        }
    </style>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

    <div id="floating-toc-btn" class="hide-on-med-and-down">
        <a class="btn-floating btn-large bg-color">
            <i class="fa fa-list"></i>
        </a>
    </div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h2, h3, h4, h5'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4, h5').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换 TOC 目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2022</span>
            <a href="/about" rel="external nofollow noreferrer">xinyichen</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a> 
            <br>
			 <span id="sitetime">载入运行时间...</span>
            
            
            
            
            <br>
            
			
			 
				&nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;<span
						class="white-color">448.6k</span>&nbsp;字
             
            

                
                <script>
                    function siteTime() {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2022";
                        var startMonth = "5";
                        var startDate = "26";
                        var startHour = "21";
                        var startMinute = "10";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);
                        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                            minutes);
                        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                            diffMinutes * minutes) / seconds);
                        if (startYear == todayYear) {
                            document.getElementById("year").innerHTML = todayYear;
                            document.getElementById("sitetime").innerHTML = "本站已运行 " + diffDays + " 天 " + diffHours +
                                " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            document.getElementById("sitetime").innerHTML = "本站已运行 " + diffYears + " 年 " + diffDays +
                                " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                        }
                    }

                    setInterval(siteTime, 1000);
                </script>
            

        </div>
        <!-- <div class="col s12 m4 l4 social-link ">

















</div> -->
    </div>
</footer>

<div class="progress-bar"></div>



<!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<!-- 异步加载 search.js -->
<script src="/js/search.js"></script>

<!-- 延迟加载 search.xml -->
<script type="text/javascript">
    $(function () {
        // 延迟500毫秒加载搜索数据，避免阻塞页面加载
        setTimeout(function () {
            searchFunc("/search.xml", 'searchInput', 'searchResult');
        }, 500);
    });
</script>
<!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


<script src="/libs/materialize/materialize.min.js"></script>
<script src="/libs/masonry/masonry.pkgd.min.js"></script>
<script src="/libs/aos/aos.js"></script>
<script src="/libs/scrollprogress/scrollProgress.min.js"></script>
<script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
<script src="/js/matery.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->


<!-- Baidu Analytics -->


<!-- Baidu Push -->


    <script src="/libs/others/clicklove.js" async="async"></script>




<script type="text/javascript">
    var OriginTitile = document.title,
        st;
    document.addEventListener("visibilitychange", function () {
        document.hidden ? (document.title = "(oﾟvﾟ)ノ Hi", clearTimeout(st)) : (document.title =
            "(*´∇｀*) 欢迎回来！", st = setTimeout(function () {
            document.title = OriginTitile
        }, 3e3))
    })
</script>

<!-- 在线聊天工具  -->



<!-- 背景 canvas-nest -->



    <script src="/libs/instantpage/instantpage.js" type="module"></script>


</body>
</html>